# 임계영역을 제거하라
## 스레드와 공유 상태의 문제

- 운영 체제는 스레드를 시분할하거나 멀티코어를 활용해 여러 작업을 동시에 실행
    - 그러나 스레드 전환 시점은 예측할 수 없기 때문에 실행 순서에 의존한 코드는 문제가 발생
    - 가변 변수를 여러 스레드가 동시에 수정하면 증가 연산이 누락되는 등 데이터 불일치가 발생
    - 리스트를 순회하면서 다른 스레드가 수정하면 `ConcurrentModificationException`이 발생
        - 이러한 문제는 재현과 디버깅이 어려운 심각한 버그 유발
- 코루틴을 사용하더라도 공유 상태를 다루는 문제는 동일하게 발생
- 여러 개의 스레드가 수정할 수 있는 공유 상태가 있다면, 공유 상태에 대한 모든 연산이 올바르게 실행되고 있는지 확인

## 코틀린/JVM의 동기화

- 동기화는 코틀린/JVM 플랫폼에서 공유 상태를 다루는 가장 중요한 도구
    - 공유 상태란 여러 스레드에서 사용되는 상태를 의미
    - `synchronized` 함수를 기반으로 하여, 오직 하나의 스레드만 특정 코드 블록을 실행할 수 있도록 보장
        - 이 메커니즘은 동시에 동일한 잠금 객체를 가진 동기화 블록에 오직 하나의 스레드만 진입할 수 있도록 보장
        - 스레드가 동기화 블록에 도달했으나, 다른 스레드가 이미 동일한 잠금 객체로 블록을 실행 중인 경우, 해당 스레드는 다른 스레드의 실행이 끝날 때까지 대기
    - 코틀린 코루틴을 사용한다면 일반적으로 `Mutex` 혹은 싱글 스레드로 제한된 디스패처를 사용

## 아토믹 객체

- 여러 단계로 실행되는 프로세스일 경우, 운영 체제는 단계 중간에 스레드 간 전환을 할 수 있기 때문에 오류를 발생시킬 수 있음
- 간단한 값 할당과 같은 일부 작업은 단일 프로세서 단계로 이루어지므로 항상 올바르게 실행
    - 원자적으로 실행되는 작업
- 자바는 주로 원자적 연산이 포함된 `AtomicXXX` 등의 원자성 클래스 제공
    - 아토믹 객체는 빠르고 상태가 단순한 값 또는 의존성이 없는 값들인 경우에 사용
    - 다수의 객체를 대상으로 하는 연산들을 동기화하는데는 아토믹 객체 사용 불가하며 이런 경우 동기화 블록 사용

## 동시성 컬렉션

- 자바는 동시성을 지원하는 컬렉션 제공
- `ConcurrentHashMap`
    - 스레드 안전
    - 해당 컬렉션을 순회하면 해당 시점의 상태를 스냅샷으로 얻을 수 있으므로 `ConcurrentModificationException` 예외가 발생하지 않음
        - 가장 최신의 상태를 얻는 것은 아님(=스냅샷)
    - `newKeySet` 을 통해 일반적인 Set 컬렉션 기능 사용 가능
        - `MutableSet` 인터페이스 구현
- `ConcurrentLinkedQueue`
    - 중복이 허용되는 동시성 컬렉션이 필요한 경우 일반적으로 리스트 대신 사용
    - 가변 상태에 대한 문제를 처리하기 위해 JVM에서 사용할 수 있는 필수 도구
- 이외에도 멀티플랫폼 아토믹 객체를 제공하는 `AtomicFU` 와 같은 KMP 라이브러리도 존재

## 변경 가능한 지점을 유출하지 마세요

```kotlin
class UserRepositry {
		private val users: MutableList<User> = mutableListOf()

		fun loadAll(): List<User> = users
		
		fun add(user: User) {
				users += user
		}
}
```

- 읽기 전용 Public 게터를 제공하는 경우
    1. 가변 객체를 읽기 전용 타입으로 형변환
        - `MutableList`  → `List` 로의 업캐스팅
        - 읽기 전용 리스트를 받은 것으로 보이지만, 실제로는 가변 리스트의 참조이므로 값이 변경될 수 있다.
- 하나의 스레드가 `loadAll` 을 사용하여 반환받은 리스트를 읽고 동시에 다른 스레드가 이를 수정할 경우
    1. 실제 참조 대신 객체의 복사본 반환하기
        - 방어적 복사(defensive copying)
        - 그러나 복사하는 동안 다른 스레드에서 목록에 새로운 요소를 추가하게 되면 충돌 발생
        - 멀티스레드 접근을 지원하기 위해 이 작업을 동기화할 것
        
        ```kotlin
        class UserRepositry {
        		private val users: MutableList<User> = mutableListOf()
        		private val LOCK = Any()
        
        		fun loadAll(): List<User> = synchronized(LOCK) {
        				users.toList()
        		}
        		
        		fun add(user: User) = synchronized(LOCK) {
        				users += user
        		}
        }
        ```
        
        - 컬렉션은 `toList` 와 같은 변환 함수를 사용하여 복사할 수 있고, 데이터 클래스는 `copy` 메서드를 사용하여 복사
    2. 읽기 전용 리스트 사용
        - 읽기 전용 리스트에 멀티스레드 접근을 허용하려면 리스트 수정 연산만 동기화할 수 있음
            - 요소 추가는 느려질 수 있으나 리스트에 대한 접근은 빨라짐
    
    ```kotlin
    class UserRepositry {
    		private val users: List<User> = listOf()
    		private val LOCK = Any()
    
    		fun loadAll(): List<User> = users
    		
    		fun add(user: User) = synchronized(LOCK) {
    				users = users + user
    		}
    }
    ```
    

## 요약

- 여러 스레드가 같은 상태를 수정하면 충돌이 발생해 데이터 손실 및 예상치 못한 사이드 이펙트 발생할 수 있음
    - 이를 스레드 안전하지 못하다고함
        - 스레드 안정성이 떨어진다
- 동시 수정으로부터 상태를 보호하기 위해 동기화를 필수적으로 사용해야 한다.
    - 대표적으로 `synchronized` 가 있다.
        - 많은 JCF 혹은 라이브러리들 내부코드를 보면 자주 사용하는 것을 볼 수 있다.
    - 코루틴을 사용한다면, `mutex` 를 일반적으로 사용
- 동시 수정을 처리하기 위해 자바는 원자성 클래스 및 동시성 컬렉션 제공
    - 원자성 클래스는 빈번히 사용하지 않으나 동시성 컬렉션은 실제 많은 회사에서 아직도 사용
    - 안드로이드에서 사용하는 대표적인 원자성 연산은 MutableStateFlow의 값을 업데이트할 때 사용하는 `update` 블럭이 있음
- AotmicFU와 같은 멀티플랫폼을 위한 아토믹 객체를 제공하는 라이브러리도 있음
- 클래스는 내부 상태를 보호해야 하며 밖으로 노출해서는 안됨
    - 읽기 전용 객체로 작업 수행
    - 방어적 복사
