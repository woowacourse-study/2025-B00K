# 1장. 처음 만드는 안드로이드 애플리케이션

## 앱 기본사항

- 하나의 Activity + 하나의 layout으로 구성
- Activity는 사용자의 interface를 처리
- Layout은 UI 객체들과 이 객체들의 화면의 위치를 정의

## 안드로이드 프로젝트 생성하기

- 안드로이드 앱은 **고유한 패키지 이름**을 가져야함
    
    → `why` 앱이 설치되거나 배포되는 각 장치나 구글 플레이 스토어에서 **식별**이 가능해야하기 때문이다.
    

## UI 레이아웃 디자인하기

- `View`: UI를 만드는 데 사용되는 구성요소 → 즉, 장치 화면에 보이는 모든것이 뷰!
- `Widget`: 사용자가 화면을 보면서 상호 작용하는 뷰
    - ex ) 텍스트, 그래픽, 터치 작업 수행 등등
- `ViewGroup`: 다른 뷰를 포함하고 화면에 보여줌 → But, 그 자신은 화면에 나타나지 않음!
    - ex) ConstraintLayout, LinearLayout, FrameLayout

### 뷰 계층 구조(View Hierarchy)

- 위젯은 **View 객체의 계층 구조**에 존재
- 이 예시에서 뷰 그룹은 LinearLayout임
    - LinearLayout은 위젯들을 하나의 열이나 행으로 뷰를 배열하고 싶을 때 사용하는 레이아웃
- `ViewGroup`에 포함되는 뷰를 해당 `ViewGroup`의 **자식(child**)

### 위젯 속성

**android:layout_width와 android:layout_height**

- `match_parent`: 자신의 부모만큼의 크기가 된다
- `wrap_content`: 자신이 갖는 콘텐츠에 필요한 크기가 된다.
- viewGroup의 부모는 **안드로이드에서 제공하는 뷰**이다.

**android:orientation**

- LinearLayout에서 자식들이 수직 또는 수평 중 어떤 형태로 나타낼지를 결정

**android:text**

- 별도의 파일에 문자열 값을 두고 그것을 참조하는 것이 좋음
    - `why` → 여러 나라의 언어를 지원하기 위한 **지역화**를 쉽게 할 수 있기 때문

## 레이아웃 XML에서 뷰 객체로

- `AppCompatActivity`: 안드로이드 Activity 클래스의 서브 클래스
- Activity.setContentView(layoutResId: Int) → 이 함수는 레이아웃을 inflate해 화면에 나타냄
    - 레이아웃이 인플레이트되면, 레이아웃 파일에 있는 각 위젯이 자신의 속성에 정의된 대로 인스턴스를 생성
    - 이 함수를 호출할 때, 인플레이트될 레이아웃의 리소스 ID를 인자로 전달

### 리소스와 리소스 ID

- 레이아웃 == 리소스
    - 리소스: 애플리케이션의 일부, 코드가 아닌 이미지 파일, 오디오 파일,xml
    - 코드에서 사용하기 위해서, 리소스의 리소스 ID를 지정
    - 안드로이드 빌드 도구가 R.class에 자동 생성
- android:id 속성은 ID를 생성, android:text 속성은 문자열을 참조

## 위젯을 코드와 연결하기

- 인플레이트된 View 객체들의 참조를 얻는다.
- 이 객체들에 리스너를 설정해 사용자 액션에 응답한다.

### 위젯의 참조 얻기

- findViewById(Int)를 호출해 View객체로 인플레이트된 위젯의 참조를 얻음
- 위젯의 리소스 ID를 인자로 받아서 해당 위젯의 객체를 반환
    
    > lateinit의 지정한 이유
    1. 코틀린에서 클래스 속성을 정의할 때 초기화하지 않으면 컴파일 에러 발생
    2. 컴파일 시점에 초기화될 수 없기 때문
    > 

### 리스너 설정하기

- 안드로이드 애플리케이션은 **이벤트 기반**으로 구동 → 즉, 구동이 되면, 이벤트를 기다림
