## 코루틴 단위 테스트 시작하기

### 첫 코루틴 테스트 작성하기

```kotlin
class RepeatAddUseCase {
    suspend fun add(repeatTime: Int): Int = withContext(Dispatchers.Default) {
        var result = 0

        repeat(repeatTime) {
            result += 1
        }
        return@withContext result
    }
}
```

```kotlin
class RepeatAddUseCaseTest{
    @Test
    fun `100번 더하면 100이 반환된다`() {
        val repeat = RepeatAddUseCase()
        
        val result = repeat.add(100)
        
        assertEquals(100, result)
    }
}
```

→ `add()` 함수는 suspend 이나, test 코드는 일반 함수라 컴파일 에러 발생

<img width="1734" height="650" alt="image" src="https://github.com/user-attachments/assets/bcb05fbd-1e6f-4ae8-a4e4-4c28814e13d1" />

→ 해결 방법: `runBlocking` 을 붙인다.

```kotlin
class RepeatAddUseCaseTest {
    @Test
    fun `100번 더하면 100이 반환된다`() = runBlocking {
        val repeat = RepeatAddUseCase()

        val result = repeat.add(100)

        assertEquals(100, result)
    }
}
```

### runBlocking 을 사용한 테스트의 한계

- runBlocking 사용한 테스트 실행 오랜 시간 걸리는 일시 중단 함수 실행 시 문제 발생

```kotlin
class RepeatAddUseCase {
    suspend fun add(repeatTime: Int): Int {
        var result = 0

        repeat(repeatTime) {
            delay(100L)
            result += 1
        }
        return result
    }
}
```

```kotlin
class RepeatAddUseCaseTest {
    @Test
    fun `100번 더하면 100이 반환된다`() = runBlocking {
        val testCoroutineScheduler = TestCoroutineScheduler()
        val testDispatcher = StandardTestDispatcher(testCoroutineScheduler)
        val repeat = RepeatAddUseCase()

        var result = 0
        CoroutineScope(testDispatcher).launch {
            result = repeat.add(100)
            assertEquals(100, result)
        }

        testCoroutineScheduler.advanceUntilIdle()
        assertEquals(100, result)
    }
}
```

→ but, 시간 소요 많이 됨

- **테스트 시 많은 시간이 소요된다면 아무도 테스트 실행하지 않으려 할 것이다.**

## 코루틴 테스트 라이브러리

- 코루틴 스케줄러를 제공해서 시간이 걸리는 작업을 해결한다.

### 코루틴 테스트 라이브러리 의존성 설정하기

```kotlin
dependencies {
	testImplementation("org.jetbrains.kotlinx:kotlinx-coroutines-test:1.7.2")
```

### TestCoroutineSchedular 사용해 가상 시간에서 테스트 진행하기

- 시간 오래 걸리는 테스트 작업을 TestCoroutineSchedular 을 통해 단번에 진행될 수 있도록 만들 수 있다.
1. advanceTimeBy 사용해 가상 시간 흐르게 만들기
    - `advanceTimeBy` 함수: 함수의 인자로 입력된 값만큼 가상 시간이 밀리초 단위로 흐른다.
        
        → 가상 시간 얼마나 흘렀는지 확인할 땐 TestCoroutineSchedular 객체의 `currentTime` 프로퍼티 사용
        
    
    ```kotlin
        @OptIn(ExperimentalCoroutinesApi::class)
        @Test
        fun `가상 시간 조절 테스트`() {
            val testCoroutineScheduler = TestCoroutineScheduler()
    
            testCoroutineScheduler.advanceTimeBy(5000L)
            assertEquals(5000L, testCoroutineScheduler.currentTime)
        }
    ```
    
2. TestCoroutineSchedular와 StandardTestDispatcher 사용해 가상 시간 위에서 테스트 진행하기
    - 가상 시간을 어떻게 사용할까?
        
        → `StandardTestDispatcher` 와 함께 사용한다.
        
    
    ```kotlin
    
        @Test
        fun `가상 시간 위에서 테스트 진행`() {
            val testCoroutineScheduler = TestCoroutineScheduler()
            val testDispatcher = StandardTestDispatcher(testCoroutineScheduler)
            val testCoroutineScope = CoroutineScope(context = testDispatcher)
    
            // given:
            var result = 0
    
            // when:
            testCoroutineScope.launch {
                delay(10000L)
                result = 1
                delay(10000L)
                result = 2
                println(Thread.currentThread().name)
            }
    
            // then:
            assertEquals(0, result)
            testCoroutineScheduler.advanceTimeBy(5000L) // 5초 후
            assertEquals(0, result)
            testCoroutineScheduler.advanceTimeBy(6000L) // 11초 후
            assertEquals(1, result)
            testCoroutineScheduler.advanceTimeBy(10000L) // 21초 후
            assertEquals(2, result)
        }
    ```
    
3. advanceUntilIdle 사용해 모든 코루틴 실행시키기
    - 테스트 실행 위해서는 테스트 대상 코드 모두 실행 후 단언이 실행돼야 한다.
        
        → `advanceUntilIdle` 함수를 사용해서 모든 디스패처와 연결된 작업이 완료될 때까지 가상의 시간을 흐르게 할 수 있다.
        
    
    ```kotlin
    @Test
        fun `advanceUntilIdle 동작`() {
            val testCoroutineScheduler = TestCoroutineScheduler()
            val testDispatcher = StandardTestDispatcher(testCoroutineScheduler)
            val testCoroutineScope = CoroutineScope(context = testDispatcher)
    
            // given:
            var result = 0
    
            // when:
            testCoroutineScope.launch {
                delay(10000L)
                result = 1
                delay(10000L)
                result = 2
            }
            testCoroutineScheduler.advanceUntilIdle()
    
            // then:
            assertEquals(2, result)
        }
    ```
    

### TestCoroutineSchedular 를 포함하는 StandardTestDispatcher
<img width="1660" height="330" alt="image" src="https://github.com/user-attachments/assets/aa346d98-0998-44fa-b2e8-6f76b44200c2" />




- StandardTestDispatcher 에서 기본적으로 TestCoroutineSchedular 를 생성한다. (따로 생성 필요 X)
    
    <img width="1249" height="1128" alt="image" src="https://github.com/user-attachments/assets/cdeb7b81-2fa2-48c3-ac8b-79433557446c" />
    
    ```kotlin
     @Test
        fun `standardTestDispatcher 사용`() {
            val testDispatcher = StandardTestDispatcher()
            val testCoroutineScope = CoroutineScope(context = testDispatcher)
    
            // given:
            var result = 0
    
            // when:
            testCoroutineScope.launch {
                delay(10000L)
                result = 1
                delay(10000L)
                result = 2
            }
            testDispatcher.scheduler.advanceUntilIdle()
    
            // then:
            assertEquals(2, result)
        }
    ```
    

### TestScope 사용해 가상 시간에서 테스트 진행하기

- `TestCoroutineSchedular` 객체 생성하는 부분은 제거했지만, TestCoroutineScope 에서 TestDispatcher 를 생성한 객체를 감싸야 한다.
    
    → 이것을 해결하기 위해 TestDispatcher 객체 가진 TestScope 객체가 반환된다.
    
    ```kotlin
    @Test
        fun `testScope 사용`() {
            val testCoroutineScope = TestScope()
    
            // given:
            var result = 0
    
            // when:
            testCoroutineScope.launch {
                delay(10000L)
                result = 1
                delay(10000L)
                result = 2
            }
            testCoroutineScope.advanceUntilIdle()
    
            // then:
            assertEquals(2, result)
        }
    ```
    

<img width="1249" height="1128" alt="image" src="https://github.com/user-attachments/assets/64250526-84cf-4cb5-b266-88a2ec38219f" />


### runTest 사용해 테스트 만들기

1. runTest 사용해 TestScope 대체하기
- `runTest` : TestScope 객체 사용해 코루틴 실행 → 내부에서 일시 중단 함수 실행되어도 바로 실행 완료 될 수 있도록 가상 시간 흐르게 만드는 기능 가진 코루틴 빌더

```kotlin
@Test
    fun `runTest 사용`() {
        // given:
        var result = 0

        // when:
        runTest {
            delay(10000L)
            result = 1
            delay(10000L)
            result = 2
        }

        // then:
        assertEquals(2, result)
    }
```

<img width="528" height="84" alt="image" src="https://github.com/user-attachments/assets/e519edd5-55f6-4f05-9125-83583209d5d0" />

- 실제 테스트 시간은 30ms 밖에 걸리지 않음.
    
    <img width="1177" height="1233" alt="image" src="https://github.com/user-attachments/assets/acfb8d27-5b5a-4366-ad3d-baff868bb44b" />

    
1. runTest 로 테스트 전체 감싸기
    
    ```kotlin
    @Test
        fun `runTest 감싸기`() = runTest {
            // given:
            var result = 0
    
            // when:
            delay(10000L)
            result = 1
            delay(10000L)
            result = 2
            
    
            // then:
            assertEquals(2, result)
        }
    ```
    
2. runTest 함수의 람다식에서 TestScope 사용하기
    - runTest 함수는 람다식에서 TestScope 객체를 수신 객체로 가져 `this` 통해 TestScope 접근 가능
    
    ```kotlin
    @Test
        fun `runTest 가상 시간 확인`() = runTest { // this: TestScope
            delay(10000L)
            println("가상 시간: ${this.currentTime}ms")
            delay(10000L)
            println("가상 시간: ${this.currentTime}ms")
        }
    ```
    
    - **runtTest 함수는 runTest 함수로 생성된 내부에서 실행된 일시 중단 함수에 대해서만 가상 시간이 흐르게 만들며, TestScope 상에서 실행된 일시 중단 함수에 대해서는 자동으로 시간을 흐르게 하지 않는다.**

## 코루틴 테스트 심화

### 함수 내부에서 새로운 코루틴을 실행하는 객체에 대한 테스트

```kotlin
class A {
    private val coroutineScope = CoroutineScope(Dispatchers.IO)
    
    var string = ""
        private set
    
    fun update(new: String) {
        coroutineScope.launch { 
            delay(1000L)
            string = new
        }
    }
}

@Test
    fun `update 테스트`() = runTest {
        // given:
        val a = A()

        // when:
        a.update("abc")

        // then:
        advanceUntilIdle()
        assertEquals("abc", a.string)

    } // 실패
```

- coroutineScope 객체에 실패 이유가 있다.
    - **CoroutineScope 객체는 별도의 루트 Job 객체를 가져 runTest 로 생성되는 코루틴과 구조화되지 않기 때문이다.**

### backgroundScope를 사용해 테스트 만들기

- runTest 함수 사용해 테스트 진행 시 runTest 함수 호출해 생성되는 코루틴은 메인 스레드를 사용하며, 내부의 모든 코루틴이 실행될 때까지 종료되지 않는다.
- 무한히 실행되는 작업 테스트하기 위해서 runTest 람다식의 수신 객체 TestScope 가 제공하는 `backgroundScope` 사용해야 한다.
    - backgroundScope 는 runTest 코루틴 모든 코드 실행 시 자동으로 취소 → 무한히 실행되는 것을 방지할 수 있다.
    
    ```kotlin
    @Test
        fun `backgroundScope 사용`() = runTest {
            var result = 0
    
            backgroundScope.launch {
                while (true) {
                    delay(1000L)
                    result += 1
                }
            }
            advanceTimeBy(1500L)
            assertEquals(1, result)
            advanceTimeBy(1000L)
            assertEquals(2, result)
        }
    ```
