# 아이템 2 - 임계 영역을 제거하라

## 스레드와 공유 상태의 문제

운영체제는 스레드 개념이 도입되어 있다

- 음악 재생, 슬랙에 메시지 표시, 브라우저에서 데이터 다운로드

운영체제는 각각의 분리된 흐름인 스레드의 실행을 스케줄링한다

싱글코어 CPU를 가졌더라도, 운영체제는 하나의 스레드를 짧은 시간 실행한 다음, 다른 스레드로 전환하는 방식으로 동시에 여러 스레드를 실행할 수 있다 → 시분할

최신 컴퓨터는 여러 개의 코어를 가지고 있어 운영체제는 실제로 많은 작업을 서로 다른 스레드에서 한 번에 실행

이런 프로세스의 가장 큰 문제 → 운영체제가 언제 한 스레드에서 다른 스레드로 실행을 전환할지 확신할 수 없다는 것

```kotlin
var num = 0
for (i in 1..1000) {
	thread {
		Thread.sleep(10)
		num += 1
	}
}
Thread.sleep(5000)
print(num) // 실행할 때마다 매번 1000이 아닌 다른 숫자가 출력됨 -> 일부 작업 손실
```

일부 작업 손실은 실제 애플리케이션에서 심각한 문제 → 재현하고 고치기 어려운 버그가 됨

실제 애플리케이션에서 가변성을 피할 수 없는 경우가 종종 있으므로 공유 상태를 다루는 방법을 배워야 함

여러 개의 스레드가 수정할 수 있는 공유 상태가 있다면, 공유 상태에 대한 모든 연산이 올바르게 실행되고 있는지를 확인해야 함

## 코틀린/JVM의 동기화

- 코틀린/JVM 플랫폼에서 공유 상태를 다루는 가장 중요한 도구 → 동기화
- 한 번에 오직 하나의 스레드만 특정 코드 블록을 실행할 수 있도록 보장 →  synchronized 함수

synchronized 함수

- lock object와 동기화해야 하는 코드를 담은 람다 표션식 필요
- 동시에 동일한 잠금 객체를 가진 동기화 블록에 오직 하나의 스레드만 진입할 수 있도록 보장
- 스레드가 동기화 블록에 도달했지만, 다른 스레드가 이미 동일한 잠금 객체로 블록을 실행 중인 경우 해당 스레드는 다른 스레드의 실행이 끝날 때까지 기다림

```kotlin
val loack = Any()
var num = 0
for (i in 1..1000) {
	thread {
		Thread.sleep(10)
		synchronized(lock) {
			num += 1
		}
	}
}
Thread.sleep(1000)
print(num) // 1000
```

코틀린 코루틴

- synchronized 대신 Mutex나 싱글 스레드로 제한된 디스패처 사용
- 스레드 전환은 비용이 발생
- 일부 클래스에서는 여러 스레드에서 실행을 동기화하는 것보다 싱글 스레드가 더 효율적

## 아토믹 객체

원자적으로 실행되는 작업

- 단일 프로세서 단계로 이루어진 매우 간단한 작업인 경우에 한정
- 자바는 자바 클래스에 원자적 연산이 포함된 AtomicInteger, AtomicLong, AtomicBoolean, AtomicReference 등 원자성 클래스 제공

AtomicInteger를 사용하여 올바르게 변수를 증가시키는 방법

```markdown
val num = AtomicInteger(0)
for (i in 1..1000) {
	thread {
		Thread.sleep(10)
		num.incrementAndGet()
	}
}
Thread.sleep(5000)
print(num.get()) // 1000
```

아토믹 객체

- 빠르다
- 상태가 단순한 값 또는 의존성이 없는 값들인 경우 사용할 수 있다
- 다수의 객체를 대상으로 하는 연산들을 동기화하는 데에는 아토믹 객체를 사용할 수 없다 → 이런 경우에는 동기화 블록을 사용해야 함

## 동시성 컬렉션

자바는 동시성을 지원하는 컬렉션도 제공

동시성을 지원하는 컬렉션 중 가장 중요한 것 = HashMap의 thread-safe 버전인 ConcurrentHashMap

- 충돌 걱정 없이 ConcurrentHashMap의 모든 연산을 안전하게 사용
- 이 컬렉션을 순회하면 해당 시점의 상태를 스냅샷으로 얻을 수 있음 → ConcurrentModificationException 예외가 발생하지 않지만, 이것이 가장 최신의 상태를 얻게 됨은 아님

```kotlin
val map = ConcurrentHashMap<Int, String>()
for (i in 1..1000) {
	thread {
		Thread.sleep(1)
		map.put(i, "E$i")
	}
	thread {
		Thread.sleep(1)
		print(map.toList().sumOf { it.first })
	}
}
```

동시성을 지원하는 Set이 필요할 때 많이 사용되는 선택지 = ConcurrentHashMap의 newKeySet

- newKeySet은 MutableSet 인터페이스를 구현, 일반적인 Set처럼 사용

```kotlin
val set = ConcurrentHashMap.newKeySet<Int>()
for (i in 1..1000) {
	thread {
		Thread.sleep(1)
		set += i
	}
}
Thread.sleep(5000)
println(set.size)
```

중복이 허용되는 동시성 컬렉션이 필요한 경우 → 리스트 대신 ConcurrentLinkedQueue

- 가변 상태에 대한 문제를 처리하기 위해 JVM에서 사용할 수 있는 필수 도구
- 동기화 지원하는 라이브러리 → 멀티플랫폼 아토믹 객체를 제공하는 AtomicFU

```kotlin
val num = atomic(0)
for (i in 1..1000) {
	thread {
		Thread.sleep(10)
		num.incrementAndGet()
	}
}
Thread.sleep(5000)
print(num.value) // 1000
```

# 변경 가능한 지점을 유출하지 마세요

```kotlin
data class User(val name: String)

class UserRepository {
	private val users: MutableList<User> = mutableListOf()
	
	fun loadAll(): MutableList<User> = users
	
	// ...
}
```

loadAll을 사용하여 UserRepository의 비공개 상태를 변경할 수 있다

```kotlin
val userRepository = UserRepository()

val users = userRepository.loadAll()
users.add("AAA")

// ...

print(userRepository.loadAll()) // [User(name=AAA)]
```

가변 객체를 읽기 전용 타입으로 형변환 → MutableList에서 List로의 업캐스팅

```kotlin
data class User(val name: String)

class UserRepository {
	private val users: MutableList<User> = mutableListOf()
	
	fun loadAll(): List<User> = users
	
	// ...
}
```

1. 읽기 전용 리스트를 받은 것으로 보이지만, 실제로는 가변 리스트의 참조이므로 값이 변경될 수 있음
2. 하나의 스레드가 loadAll()을 사용하여 반환받은 리스트를 읽고 동시에 다른 스레드가 이를 수정하는 상황이 발생한다면, ConcurrentModificationException 발생

해결 방법

1. 실제 참조 대신 객체의 복사본을 반환 → 방어적 복사 (defensive copying)
2. 읽기 전용 리스트 사용

방어적 복사를 수행하면, 복사하는 동안 다른 스레드에서 목록에 새로운 요소를 추가하게 되면 충돌이 발생함

- 멀티스레드 접근을 지원하려면 이 작업을 동기화해야 함
- 컬렉션은 toList와 같은 변환 함수를 사용하여 복사할 수 있음
- 데이터 클래스는 copy()를 사용하여 복사할 수 있음

```kotlin
class UserRepository {
	private val users: MutableList<User> = mutableListOf()
	private val LOCK = Any()
	
	fun loadAll(): List<User> = synchronized(LOCK) {
		users.toList()
	}
	
	fun add(user: User) = synchronized(LOCK) {
		users += user
	}
}
```

읽기 전용 리스트는 안전하고 객체의 변경사항을 추적하기에 용이

```kotlin
class UserRepository {
	private val users: List<User> = litOf()
	
	fun loadAll(): List<User> = users
	
	fun add(user: User) {
		users = users + user
	}
}
```

읽기 전용 리스트에 멀티스레드 접근을 허용하려면 리스트 수정 연산만 동기화하면 됨

요소 추가는 느려지지만 리스트에 대한 접근은 빨라짐 → 쓰기보다 읽기가 많을 때 좋은 trade-off

```kotlin
class UserRepository {
	private val users: List<User> = litOf()
	private val LOCK = Any()
	
	fun loadAll(): List<User> = users
	
	fun add(user: User) = synchronized(LOCK) {
		users = users + user
	}
}
```
