# 아이템 4 - 변수의 스코프를 최소화하라

상태 정의할 때

- 프로퍼티보다 지역 변수 사용
- 최대한 좁은 스코프를 갖는 변수 사용
    - 반복문 내부에서만 변수가 사용된다면 변수를 반복문 내부에 작성

요소의 스코프

- 요소를 볼 수 있는 컴퓨터 프로그램 영역

코틀린 스코프

- 중괄호로 만들어짐
- 내부 스코프에서 외부 스코프에 있는 요소에만 접근 가능

```kotlin
val a = 1
fun fizz() {
	val b = 2
	print(a + b)
}
val buzz = {
	val c = 3
	print(a + c)
}
// 이 위치에서 a는 사용 가능, b와 c는 사용 불가
```

- fizz()와 buzz 함수의 스코프에서는 외부 스코프에 있는 변수에 접근할 수 있음
- 외부 스코프에서는 내부 스코프에 정의된 변수에 접근할 수 없음

변수 스코프를 제한하는 예시

```kotlin
// Don't
var user: User
for (i in users.indices) {
	user = users[i]
	print("User at $i is $user")
}
```

- 변수 user는 for 반복문 스코프 내부뿐만 아니라 외부에서도 사용할 수 있음

```kotlin
// Better
for (i in users.indices) {
	val user = users[i]
	print("User at $i is $user")
}
```

- user의 스코프를 for 반복문 내부로 제한

```kotlin
// Best
for ((i, user) in users.withIndex()) {
	print("User at $i is $user")
}
```

- user의 스코프를 for 반복문 내부로 제한

스코프 내부에 스코프

- 람다 표현식 내부의 람다 표현식

⇒ 최대한 변수는 스코프를 좁게 설정하는 것이 좋음

스코프를 좁게 만드는 것의 장점

- 프로그램을 추적하고 관리가 쉬움
    - 코드를 분석할 때 어떤 시점에 어떤 요소가 있는지 알아야 함
    - 요소가 많아져 프로그램에 변경될 수 있는 부분이 많아지면 프로그램을 이해하기 어려워짐
- 애플리케이션이 간단할수록 읽기 쉽고 안전
- mutable 프로퍼티는 좁은 스코프에서 사용할수록 변경을 추적하는 것이 쉬움

스코프 범위가 넓을 때의 문제

- 다른 개발자에 의해 변수가 잘못 사용될 수 있음

변수 Best Practice

- 읽기 전용 또는 쓰기 전용 여부와 상관 없이 변수를 정의할 때 초기화
- if, when, try-catch, Elvis 등 활용하면 최대한 변수를 정의할 때 초기화 가능

```kotlin
// Don't
val user: User
if (hasValue) {
	user = getValue()
} else {
	user = User()
}
```

```kotlin
// Better
val user: User = if (hasValue) {
	getValue()
} else {
	User()
}
```

여러 프로퍼티를 한꺼번에 설정해야 하는 경우

- 구조분해 선언(destructuring declaration) 활용

```kotlin
// Don't
fun updateWeather(degrees: Int) {
	val description: String
	val color: Int
	if (degrees < 5) {
		description = "cold"
		color = Color.BLUE
	} else if (degrees < 23) {
		description = "mild"
		color = Color.YELLOW
	} else {
		description = "hot"
		color = Color.RED
	}
}
```

```kotlin
// Better
fun updateWeather(degrees: Int) {
	val (description,color) = when {
		degrees < 5 -> "cold" to Color.BLUE
		degrees < 23 -> "mild" to Color.YELLOW
		else -> "hot" to Color.RED
	}
}
```

### 캡처링

시퀀스 빌더를 사용한 소수를 구하는 알고리즘 (에라토스테네스의 체) 구현

- 알고리즘 개념
1. 2부터 시작하는 숫자 리스트를 만든다
2. 첫 번째 요소를 선택 → 소수
3. 남아 있는 숫자 중에서 2번에서 선택한 소수로 나눌 수 있는 모든 숫자를 제거

```kotlin
var number = (2..100).toList()
val primes = mutableListOf<Int>()
while (numbers.isNotEmpty()) {
	val prime = numbers.first()
	primes.add(prime)
	numbers = numbers.filter { it % prime != 0 }
print(primes)
```

```kotlin
// 시퀀스 활용

val primes: Sequence<Int> = sequence {
	var numbers = generateSequence(2) { it + 1 }
	while (true) {
		val prime = numbers.first()
		yield(prime)
		numbers = numbers.drop(1).filter { it % prime != 0 }
	}
}
print(primes.take(10).toList())
```

```kotlin
// 시퀀스 활용 But, 잘못된 결과

val primes: Sequence<Int> = sequence {
	var numbers = generateSequence(2) { it + 1 }
	var prime: Int
	while (true) {
		prime = numbers.first()
		yield(prime)
		numbers = numbers.drop(1).filter { it % prime != 0 }
	}
}
print(primes.take(10).toList())
// [2, 3, 5, 6, 7, 8, 9, 10, 11, 12]
```

- prime이라는 변수를 캡처해서 결과가 잘못 나옴
- 반복문 내부에서 filter를 활용해서 prime으로 나눌 수 있는 숫자를 필터링
- 시퀀스를 활용하므로 필터링이 지연
- 최종적인 prime 값으로만 필터링된 것
- prime이 2로 설정되어 있을 때 필터링된 4를 제외하면 drop만 동작하므로 그냥 연속된 숫자가 나옴

⇒ 항상 잠재적인 캡처 문제를 주의해야 함
