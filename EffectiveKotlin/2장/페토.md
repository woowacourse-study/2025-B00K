### 1. 스레드와 공유 상태의 문제

여러 스레드에서 공유 상태를 동시에 수정할 때 예상치 못한 결과 발생
Time slicing으로 인해 스레드 실행 순서가 보장되지 않음
1000개의 스레드가 각각 변수를 증가시켜도 결과가 1000이 아닐 수 있음

### 2. 해결 방법들
- 코루틴/JVM의 동기화

#### synchronized 키워드 사용
- lock object를 통해 한 번에 하나의 스레드만 접근 가능하도록 제어

#### 아토믹 객체
- AtomicInteger, AtomicLong, AtomicBoolean, AtomicReference 등 제공
- incrementAndGet() 같은 원자적 연산 메서드 제공

#### 동시성 컬렉션
- ConcurrentHashMap: thread-safe한 HashMap
- ConcurrentLinkedQueue: 일반 리스트 대신 사용 가능

3. 변경 가능한 지점을 유출하지 마세요
MutableList를 직접 반환하면 외부에서 수정 가능하여 위험
- List로 업캐스팅하여 반환
- toList()로 복사본 생성
- defensive copying 사용
