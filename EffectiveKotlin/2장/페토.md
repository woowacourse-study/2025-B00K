## 변수의 스코프를 최소화하라

상태를 정의할 때 변수와 프로퍼티의 스코프를 최소화하는 것이 좋다.
- 프로퍼티보다 지역 변수를 사용하라
- 변수의 스코프를 최대한 좁게 만들어라

#### 스코프를 줄이는 이유
- 프로그램을 추적, 관찰하기 쉽다.
코드를 분석할 때 어떤 시점에 어떤 요소가 있는지를 알아야 한다.
만약 요소가 많아진다면 프로그램에서 변경 가능한 부분이 많아져 이해하기 어려워진다.
- 다른 개발자에 의해서 변수가 오용될 수 있다.

> 변수는 val, var 상관 없이 초기화 되는 것이 좋다

조건문, 예외처리, 엘비스 연산자를 사용하면 변수를 정의할 때 초기화할 수 있다.
```
// 최악
val user: User
if(hasValue){
  user = getValue()
}else{
  user = User()
}

// 좀더 나음
val user: User = if (hasValue) {
	getValue()
} else {
	User()
}
```

여러 프로퍼티를 한거번에 설정해야 하는 경우 구조분해 선언을 사용하자

### 캡처링

시퀀스 빌더를 사용해 에러토스테네스의 체를 구현하는 예시를 살펴보자
```
val primes: Sequence<Int> = sequence {
    var numbers = generateSequence(2) { it + 1 }

    while (true) {
        val prime = numbers.first()
        yield(prime)
        numbers = numbers.drop(1)
            .filter { it % prime != 0 }
    }
}

print(primes.take(10).toList())
// [2,3,5,7,11,13,17,19,23,29]
```

이를 최적화해보자
```
val primes1: Sequence<Int> = sequence {
var numbers1 = generateSequence(2) { it + 1 }

var prime: Int
  while (true) {
      prime = numbers1.first() // 2(소수)
      yield(prime)
      numbers1 = numbers1.drop(1)
          .filter { it % prime != 0 }
  }
}

print(primes1.take(10).toList())
// [2, 3, 5, 6, 7, 8, 9, 10, 11, 12] 결과 다름 !!
```

잘못된 결과가 나온다. 이는 prime이라는 변수를 캡처했기 때문인데
반복문 내부에서 filter를 활용해 prime으로 나눌 수 있는 숫자를 필터링한다.

하지만 시퀀스는 필터링이 지연되어 최종적인 prime 으로만 필터링 된다.
