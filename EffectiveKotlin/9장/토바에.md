# 아이템 9 - use를 사용하여 리소스를 닫아라

`close()` 메서드를 사용해 명시적으로 닫아야 하는 리소스

- InputStream
- OutputStream
- java.sql.Connection
- java.io.Reader(FileReader, BufferedReader, CSSParser)
- java.new.Socket
- java.util.Scanner

⇒ 모두 AutoCloseable을 상속받는 Closeable 인터페이스를 구현함

- 리소스에 대한 레퍼런스가 없어질 때까지 가비지 컬렉터가 처리하지만, 매우 느림 (쉽게 처리되지 않음)
- 리소스를 유지하는 비용이 큼

리소스를 처리하는 방법

- try-finally 블록을 사용해서 처리

```kotlin
fun countCharatersInFile(path: String): Int {
	val reader = BufferedReader(FileReader(path))
	try {
		retrun reader.lineSequence().sumBy { it.length }
	} finally {
		reader.close()
	}
}
```

→ 코드가 복잡하다

→ 리소스를 닫을 때, 예외를 따로 처리하지 않아 예외가 발생할 수 있다

`try-finally` 블록 내부에서 오류가 발생하면, 둘 중 하나만 전파된다.

- 둘 다 전파할 수 있으면 좋지만, 직접 구현하려면 복잡하다
- 많이 사용하는 구현 방법으로 `use()` 를 사용할 수 있다

```kotlin
fun countCharatersInFile(path: String): Int {
	val reader = BufferedReader(FileReader(path))
	reader.use {
		retrun reader.lineSequence().sumBy { it.length }
	}
}
```

- `useLines()` 를 사용해 메모리에 파일의 내용을 한 줄씩만 유지하여, 대용량 파일도 적절하게 처리할 수 있다

```kotlin
fun countCharactersInFile(path: String): Int {
	File(path).useLines { lines ->
		return lines.sumBy { it.length }
	}
}
```
