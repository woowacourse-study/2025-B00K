# 아이템 5 - 예외를 활용해 코드에 제한을 걸어라

## 코틀린에서 코드의 동작에 제한을 거는 방법

- require 블록
    - 아규먼트 제한
- check 블록
    - 상태와 관련된 동작 제한
- assert 블록
    - 어떤 것이 true인지 확인
    - 테스트 모드에서만 작동
- return 또는 throw와 함께 활용하는 Elvis 연산자

```kotlin
fun pop(num: Int = 1): List<T> {
	require(num <= size) {
		"Cannot remove more elements than current size"
	}
	check(isOpen) { "Cannot pop from closed stack" }
	val ret = collection.take(num)
	collection = collection.drop(num)
	assert(ret.size == num)
	return ret
}
```

- 제한을 걸면 문서를 읽지 않은 개발자가 문제 확인 가능
- 문제가 있을 경우 함수가 예상치 못한 동작을 하지 않고 예외를 throw
- 코드가 자체적으로 검사됨 → 관련된 단위 테스트를 줄일 수 있음
- 스마트 캐스트 기능을 활용 가능 → 캐스트를 적게 할 수 있음

## 아규먼트

```kotlin
fun factorial(n: Int): Long {
	require(n >= 0)
	return if (n <= 1) 1 else factorial(n-1)
```

- 숫자를 아규먼트로 받아서 팩토리얼을 계산할 때, 숫자는 양의 정수여야 함

```kotlin
fun findClusters(points: List<Point>): List<Cluster> {
	require(points.isNotEmpty())
	// ...
}
```

- 좌표들을 아규먼트로 받아서 클러스터를 찾을 때, 비어 있지 않은 좌표 목록이 필요

```kotlin
fun sendEmail(user: User, message: String) {
	requireNotNull(user.email)
	require(isValidEmail(user.email))
	// ...
}
```

- 사용자로부터 이메일 주소를 받을 때, 값이 입력되어 있는지와 이메일 형식이 올바른지 확인

⇒ 일반적으로 require 함수 사용, 조건을 만족하지 못하면 IllegalArgumentException 발생

```kotlin
fun factorial(n: Int): Long {
	require(n >= 0) { "Cannot calculate factorial of $n because it is smaller than 0" }
	// 람다를 활용해 지연 메시지를 정의
	return if (n <= 1) 1 else factorial(n-1)
```

## 상태

- 어떤 구체적인 조건을 만족할 때만 함수를 사용할 수 있게 해야 할 때

```kotlin
fun speak(text: String) {
	check(isInitialized)
	// ...
}
```

- 어떤 객체가 미리 초기화되어 있어야만 처리를 하게 하고 싶은 함수

```kotlin
fun getUserInfo(): UserInfo {
	checkNotNull(token)
	// ...
}
```

- 사용자가 로그인했을 때만 처리를 하게 하고 싶은 함수

```kotlin
fun next(): T {
	check(isOpen)
	// ...
}
```

- 객체를 사용할 수 있는 시점에 사용하고 싶은 함수

⇒ 일반적으로 check 함수 사용, 지정된 예측을 만족하지 못할 때 IllegalStateException을 throw

## Assert 계열 함수 사용

```kotlin
class StackTest {
	@Test // 단위 테스트 - 구현의 정확성을 확인하는 가장 기본적인 방법
	fun 'Stack pops correct number of elements'() {
		val stack = Stack(20) { it }
		val ret = stack.pop(10)
		assertEquals(10, ret.size)
	}
	// ...
}
```

- 스택이 10개의 요소를 팝하면, 10개의 요소가 나온다는 보편적인 사실을 테스트
    - 테스트해서 모든 상황에서 괜찮을지는 알 수 없음

```kotlin
fun pop(num: Int = 1): List<T> {
	// ...
	assert(ret.size == num)
	return ret
}
```

- 모든 pop 호출 위치에서 제대로 동작하는지 확인
- 해당 조건은 코틀린/JVM에서만 활성화
    - -ea JVM 옵션을 활성화해야 확인 가능
- 표준 애플리케이션 실행에서는 assert가 예외를 throw하지 않음

## 단위 테스트 대신 함수에서 assert를 사용할 때 장점

- Assert 계열의 함수는 코드 자체를 점검
    - 더 효율적으로 테스트 가능
- 특정 상황이 아닌 모든 상황에 대한 테스트
- 실행 시점에서 정확하게 어떻게 되는지 확인
- 실제 코드가 더 빠른 시점에 실패하게 만듦
- 예상하지 못한 동작이 언제 어디서 실행되었는지 쉽게 찾을 수 있음

## nullability와 스마트 캐스팅

```kotlin
public inline fun require(value: Boolean): Unit {
	contract {
		returns() implies value
	}
	require(value) { "Failed requirement." }
}
```

- 이를 활용해 타입 비교를 했다면 스마트 캐스트 작동

```kotlin
fun changeDress(person: Person) {
	require(person.outfit is Dress)
	val dress: Dress = person.outfit
	// ...
}
```

- outfit 프로퍼티가 final이라면, outfit 프로퍼티가 Dress로 스마트 캐스트

```kotlin
class Person(val email: String?)

fun sendEmail(person: Person, message: String) {
	require(person.email != null)
	val email: String = person.email
	// ...
}
```

- 어떤 대상이 null인지 확인할 때 유용

```kotlin
class Person(val email: String?)
fun validateEmail(email: String) { /* ... */ }

fun sendEmail(person: Person, text: String) {
	val email = requireNotNull(person.email)
	validateEmail(email)
	// ...
}

fun sendEmail(person: Person, text: String) {
	requireNotNull(person.email)
	validateEmail(person.email)
	// ...
}
```

- 변수를 언팩하는 용도로 활용

```kotlin
fun sendEmail(person: Person, text: String) {
	val email: String = person.email ?: return
	// ...
}
```

- nullability를 목적
- 오른쪽에 throw 또는 return을 두고 Elvis 연산자 활용

```kotlin
fun sendEmail(person: Person, text: String) {
	val email: String = person.email ?: run {
		log("Email not send, no email address")
		return
	}
	// ...
}
```

- 프로퍼티에 문제가 있어 null이어서 여러 처리를 해야 할 때, return/throw와 run 함수를 조합해서 활용
- 함수가 중지된 이유를 로그에 출력해야 할 때 사용
