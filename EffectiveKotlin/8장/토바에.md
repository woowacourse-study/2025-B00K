# 아이템 8 - 적절하게 null을 처리하라

## null

- lack of value (값이 부족하다)
    - 프로퍼티가 null
        - 값이 설정되지 않았다
        - 값이 제거되었다
    - 함수가 null을 반환
        - String.toIntOrNull() → Int로 적절하게 변환할 수 없는 경우
        - Iterable<T>.firstOrNull() → 주어진 조건에 맞는 요소가 없는 경우
- 최대한 명확한 의미를 갖는 게 좋다

## nullable 처리 방법

- ?., 스마트 캐스팅, Elvis 연산자 활용
- 오류를 throw
- 함수 또는 프로퍼티를 리팩토링해서 nullable 타입이 나오지 않도록 변환

## null을 안전하게 처리하기

- safe call → `printer?.print()`
- smart casting → `if (printer != null) printer.print()`

## 방어적 프로그래밍

- 모든 가능성을 올바른 방식으로 처리하는 것
- 프로덕션 환경에서 발생할 수 있는 수많은 것들로부터 프로그램을 방어해서 안정성을 높이는 방법

## 공격적 프로그래밍

- 예상하지 못한 상황이 발생했을 때, 이러한 문제를 개발자에게 알려서 수정하게 만드는 것
- require, check, assert → 공격적 프로그래밍을 위한 도구

## 오류 throw 하기

- 개발자가 ‘당연히 그럴 것이다'라고 생각하게 되는 부분에서 문제가 발생할 경우에 오류를 강제로 발생시키는 것이 좋음
- throw, !!, requireNotNull, checkNotNull 등 활용

```kotlin
fun process(user: User) {
    requireNotNull(user.name)
    val context = checkNotNull(context)
    val networkService = getNetworkService(context) ?: throw NoInternetConnection()
    network.getData { data, userData ->
        show(data!!, userData!!)
    }
}
```

## not-null assertion(!!)과 관련된 문제

- 어떤 대상이 null이 아니라고 생각하고 다루면 NPE 예외 발생 → 설명 없이 제네릭 예외가 발생
- 코드가 짧고 너무 사용하기 쉽다 보니 남용
- 현재 null이 나오지 않는다는 것이 거의 확실한 상황에서 사용되지만, 미래에도 확실한 것은 아님 → 언젠가 문제 발생

```kotlin
fun largestOf(a: Int, b: Int, c: Int, d: Int): Int = listOf(a, b, c, d).max()!!

fun largestOf(vararg nums: Int): Int = listOfnums.max()!!
// vararg -> 0부터 n개까지 입력 가능
largestOf() // NPE

```

```kotlin
class UserControllerTest {
    private var dao: UserDao? = null
    private var controller: UserController? = null
    
    @BeforeEach
    fun init() {
        dao = mockk()
        controller = UserController(dao!!)
    }
    
    @Test
    fun test() {
        controller!!.doSomething()
    }
}
```

- 프로퍼티를 계속 언팩해야 하는 단점

## 의미 없는 nullability 피하기

- nullability는 어떻게든 적절하게 처리해야 하므로 추가 비용 발생
- 이유 없이 null을 사용하면 불필요한 예외 처리가 필요하다

### nullability를 피할 때 사용할 수 있는 방법

- 클래스에서 nullability에 따라 여러 함수를 만들어서 제공할 수 있음 → List<T>의 get(), getOrNull()
- 클래스 생성 이후 값이 확실하게 설정된다는 보장이 있을 때, lateinit 프로퍼티와 notNull 델리게이트 사용
- null 대신 빈 컬렉션 반환
- nullable enum 대신 None enum 사용

## lateinit 프로퍼티와 notNull 델리게이트

```kotlin
class UserControllerTest {
    private var dao: UserDao? = null
    private var controller: UserController? = null
    
    @BeforeEach
    fun init() {
        dao = mockk()
        controller = UserController(dao!!)
    }
    
    @Test
    fun test() {
        controller!!.doSomething()
    }
}
```

- 프로퍼티를 사용할 때마다 nullable에서 null이 아닌 것으로 타입 변환 해야 함
- 테스트 전에 설정될 것이라는 것이 명확하므로, lateinit 한정자를 사용하는 것이 바람직함

### lateinit

- 비용 발생
    - 내부적으로 초기화 되었는지 확인
    - 상태 예측이 어려워질 수 있어 까다로움
- 처음 사용하기 전에 반드시 초기화가 되었을 경우에만 사용
- !! 연산자로 언팩하지 않아도 됨
- 이후에 어떤 의미를 나타내기 위해 null을 사용하고 싶을 때, nullable로 만들 수 있음
- 프로퍼티가 초기화된 이후에는 초기화되지 않은 상태로 돌아갈 수 없음
- 라이프 사이클을 갖는 클래스처럼 메서드 호출에 명확한 순서가 있을 때 활용

### Delegate.notNull()

```kotlin
class DoctorActivity: Activity() {
    private var doctorId: Int by Delegates.notNull()
    private var fromNotification: Boolean by Delegates.notNull()
    
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        doctorId = intent.extras.getInt(DOCTOR_ID_ARG)
        fromNotification = intent.extras.getBoolean(FROM_NOTIFICATION_ARG)
    }
}
```

```kotlin
class DoctorActivity: Activity() {
    private var doctorId: Int by arg(DOCTOR_ID_ARG)
    private var fromNotification: Boolean by arg(FROM_NOTIFICATION_ARG)
}
```

- onCreate 때 초기화하는 프로퍼티는 지연 초기화하는 형태로 프로퍼티 위임을 사용할 수 있음
