# 아이템 8. 적절하게 Null 을 처리하라

- `String.toIntOfNull()` : String을 Int로 적절하게 변환할 수 없을 경우 null 리턴
- `Iterable<T>.firstOrNull( () → Boolean)`: 주어진 조건에 맞는 요소가 없을 경우 null 리턴
- nullable 타입은 3가지 방법으로 처리
    1. `?.`, `스마트캐스팅` , `Elvis 연산자`
    2. 오류를 throw
    3. 함수 or 프로퍼티를 리팩터링해서 nullable 타입이 나오지 않게 바꾸기
1. **null 안전하게 처리하기**
    
    ```kotlin
    printer?.print() // safe call
    if (printer != null) printer.print() // smart casting
    
    val printerName1 = printer?.name ?: "Unnamed" // elvis operator
    val printerName2 = printer?.name ?: return
    val printerName3 = printer?.name ?: 
    	throw Error("printer must be named")
    	
    val name = readLine()
    if (!name.isNullOrBlank()) {
    	println(${name.toUpperCase()})
    }
    ```
    
    - 방어적 프로그래밍과 공격적 프로그래밍
        1. 방어적 프로그래밍
            - 모든 가능성을 올바른 방식으로 처리하는 것 (null일 때는 출력하지 않기 등)
            - 프로덕션에서 발생할 수 있는 수많은 것들로부터 프로그램을 방어해서 안정성 높이는 방법
        2. 공격적  프로그래밍
            - 예상치 못한 상황 발생 시 개발자에게 알려 수정하게 만드는 것
            - require / check / assert 공격적 프로그래밍 위한 도구
        
        → 둘은 코드 안전을 위해 모두 필요하다.
        
2. **오류 throw 하기**
    - 다른 개발자가 어떤 코드를 보고 **‘당연히 그럴 것이다’라고 생각하는 부분에서 문제 발생 시 오류 강제 발생시켜 주는 것이 좋다**
    - `throw`, `!!` , `requireNotNull` , `checkNotNull`
    - not-null assertion(!!)
        - 어떤 대상이 `not-null` 이라 생각 시 NPE 발생함 (자바와 같음. 그러면 코틀린을 쓸 이유가 없음)
        - 정말 말도 안 되게 null 이 들어올 수 있어도 사용하지 않기
3. 의미없는 nullability 를 피하자
    - nullability 는 어떻게는 적절하게 처리해야 하기에 추가비용이 발생함
    - 필요한 경우가 아니면 nullability 자체를 피하자
        - 함수 사용
            - `getOrNull`
            - `firstOrNull`
        - enum 사용
4. lateinit 프로퍼티와 notNull 델리게이트
    1. lateinit
        - lateinit 을 사용하면 프로퍼티 초기화가 이후에 일어날 것임을 명시함
        - 초기화 되지 않는다면 예외가 발생하지만 바로 확인할 수 있음
    2. notNull 델리게이트
        - JVM에서 Int, Long, Double, Boolean과 같은 기본타입과 연결된 타입으로 프로퍼티를 연결해야 하는 경우 → Delegates.notNull을 사용함
