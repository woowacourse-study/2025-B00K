## 결과 부족이 발생할 경우 null과 Failure를 사용하라
함수가 원하는 결과를 만들어낼 수 없을 때 처리하는 메커니즘은 크게 다음과 같이 두 가지가 있다.
- `null` 또는 실패를 나타내는 sealed 클래스(일반적으로 Failure라는 이름 사용)
- 예외를 throw

이러한 두 가지는 중요한 차이점이 있다. 우선 예외는 정보를 전달하는 방법으로 사용해서는 안된다. </br>
예외는 오직 잘못된 특별한 상황을 표현하고 처리되어야 한다.
이러한 이유를 정리하면다음과 같다.
- 많은 개발자가 예외가 전파되는 과정을 제대로 추적하지 못한다.
- 코틀린의 모든 예외는 unchecked 예외다. 따라서 사용자가 예외를 처리하지 않을 수도 있으며 이와 관련된 내용은 문서에도 제대로 드러나지 않는다.</br>
실제로 API를 사용할 때 예외와 관련된 사항을 단순하게 메서드 등을 사용하면서 파악하기 힘들다.
- 예외는 예외적인 상황을 처리하기 위해 만들어졌으므로 명시적인 테스트만큼 빠르게 동작하지 않는다.
- try-catch 블록 내부에 코드를 배치하면 컴파일러가 할 수 있는 최적화가 제한된다.

때문에 null과 Failure는 예상되는 오류를 표현할 때 굉장히 좋다.
이는 명시적이고 효율적이기 때문에 예측이 가능한 범위의 오류라면 null과 Failure를 사용하고
예측하기 어려운 예외적인 범위의 오류는 예외를 throw해서 처리하는 것이 좋다.

```
inline fun <reified T> String.readObjectOrNull(): T? {
    // ...
	if(incorrectSign) {
    	return null
    }
    // ...
    return result
}

inline fun <reified T> String.readObject(): Result<T> {
    // ...
	if(incorrectSign) {
    	return Failure(JsonParsingException())
    }
    // ...
    return Success(result)
}

sealed class Result<out T>
class Success<out T>(val result: T): Result<T>()
class Failure<out T>(val throwable: Throwable): Result<Nothing>()
class JsonParsingException: Exception()
```
이렇게 표시되는 오류는 다루기 쉽다. null을 처리해야 한다면 사용자는 안전 호출(safe call) 또는 Elvis 연산자 같은 다양한널 안정성 기능을 활용한다.
```
// null을 리턴 했을 때
val age = userText.readObjectOrNull<Person>()?.age ?: -1

// sealed 클래스 사용했을 때
val person = userText.readObject<Person>()
val age = when(person) {
	is Success -> person.age
    is Failure -> -1
}
```

이러한 오류 처리 방식은 try-catch 블록보다 효율적이며 사용하기 쉽고 더 명확하다.
또한 추가 정보를 전달해야 한다면 sealed result를 사용하고 아니라면 null을 사용하는 것이 일반적이다.
