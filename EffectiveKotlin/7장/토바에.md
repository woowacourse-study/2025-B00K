# 아이템 7 - 결과 부족이 발생할 경우 null과 Failure를 사용하라

### 함수가 원하는 결과를 만들어낼 수 없는 예

- 서버로부터 데이터를 읽어 들이려고 했는데, 인터넷 연결 문제로 읽어 들이지 못한 경우
- 조건에 맞는 첫 번째 요소를 찾으려 했는데, 조건에 맞는 요소가 없는 경우
- 텍스트를 파싱해서 객체를 만들려고 했는데, 텍스트의 형식이 맞지 않는 경우

→ 처리하는 메커니즘 2가지

1. null 또는 ‘실패를 나타내는 sealed class’를 리턴
2. 예외를 throw

## 예외 throw

- 잘못된 특별한 상황을 나타냄
- 처리되어야 할 때
- 정보 전달 방식으로 사용 X
- 예외적인 상황이 발생했을 때 사용 O
- 예측하기 어려운 예외적인 범위의 오류

### 왜 예외를 정보전달 방식으로 사용하면 안 될까?

- 많은 개발자가 예외가 전파되는 과정을 제대로 추적하지 못함
- 코틀린의 모든 예외는 unchecked 예외 → 사용자가 처리하지 않을 수도 있음
- 예외적인 상황을 처리하기 위함이지, 명시적인 테스트만큼 빠르게 동작하지 않음
- try-catch 블록 내부에 코드를 배치하면 컴파일러가 할 수 있는 최적화가 제한

### null과 Failure는 예상되는 오류를 표현할 때 좋다

- 명시적
- 효율적
- 간단한 방법으로 처리
- 예측할 수 있는 범위의 오류는 null과 Failure 사용

```kotlin
inline fun <reified T> String.readObjectOrNull(): T? {
	// ...
	if (incorrectSign) {
		return null
	}
	// ...
	return result
}

inline fun <reified T> String.readObject(): Result<T> {
	// ...
	if (incorrectSign) {
		return Failure(JsonParsingException())
	}
	// ...
	return Success(result)
}

sealed class Result<out T>
class Success<out T>(val result: T): Result<T>()
class Failure(val throwable: Throwable): Result<Nothing>()

class JsonParsingException: Exception()
```

⇒ 표시되는 오류를 다루기 쉽고, 놓치기 어려움.

- null을 처리해야 한다면 safe call OR Elvis 연산자 등으로 널 안정성 기능을 활용해야 함

```kotlin
val age = userText.readObjectOrNull<Person>()?.age ?: -1
```

Result와 같은 공용체를 리턴하기로 했다면, when 표현식을 사용해서 이를 처리할 수 있음

```kotlin
val person = userText.readObjectOrNull<Person>()
val age = when(person) {
	is Success -> person.age
	is Failure -> -1
```

- try-catch 블록보다 효율적
- 사용하기 쉽고 명확
- 명시적으로 처리해야 하기 때문에 애플리케이션의 흐름을 중지하지 않음 → 예외는 놓칠 수 있으며 전체 애플리케이션을 중지시킬 수 있음

### 언제 null을 사용하고 언제 sealed result 클래스를 사용하나요?

- sealed result
    - 추가적인 정보를 전달해야 할 때
    - Failure는 처리할 때 필요한 정보를 가질 수 있음
- null
    - 추가적인 정보를 전달하지 않아도 될 때

### List 함수로 보는 예상할 수 있을 때와 예상할 수 없을 때 사용하는 함수

- get()
    - 특정 위치에 있는 요소를 추출할 때 사용
    - 만약 요소가 해당 위치에 없다면 IndexOutOfBoundsException 발생
- getOrNull()
    - out of range 오류가 발생할 수 있는 경우에 사용
    - 발생할 경우 null 반환
    - getOrDefault() 선택지도 존재하지만, 일반적으로 getOrNull을 사용하는 것이 쉬움 → 개발자는 자신이 요소를 언제나 안전하게 추출할 거라고 생각하기 때문. nullable 반환 값이 아닌, getOrNull 등 무엇이 리턴되는지 예측할 수 있게 하는 게 좋다.
    - 
