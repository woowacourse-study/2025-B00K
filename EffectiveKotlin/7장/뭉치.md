# 아이템 7. 결과 부족이 발생할 경우 null과 Failure를 사용하라
- 서버로 데이터 호출했는데, 인터넷 연결 문제로 읽어들이지 못할 경우 등등
    
    → 이 때 두 가지 방법으로 보편적으로 처리함
    
    1. null or 실패를 나타내는 sealed 클래스(일반적으로 ‘Failure’ 로 네이밍함)
    2. 예외를 throw
- 예외는 정보를 전달하는 방법으로 사용하면 안 된다. → 잘못된 `특별한 상황`을 나타내야 함
    - 예외적인 상황이 발생했을 때 사용하라
        1. 많은 개발자가 예외 전파되는 과정 알지 못함
        2. 코틀린의 에외는 unchecked 예외라 사용자가 예외처리 하지 않을 수 있음.
            - 사용자가 반드시 처리하게 강제되는 예외를 checked 예외라 함.
            - 처리하지 않아도 실행에 문제가 없는 것을 unchecked 예외라 함.
        3. try-catch 블록 내부에 코드 배치하면, 컴파일러가 할 수 있는 최적화가 제한됨.
- 충분히 예측 가능한 범위 → null / Failure
- 예측하기 어려운 예외 범위 → throw 하기

```kotlin
// null 처리 시 elvis 혹은 safe call
val age = userText.readObjectOrNull<Person>()?.age ?: -1
```

```kotlin
// Result 와 같은 공용체 리턴
val person = userText.readObjectOrNull<Person>()
val age = when(person) {
	is Succeess -> person.age
	is Failure -> -1
}
```

→ 그렇다면 null 과 sealed class 는 각각 언제 사용할까?

- 추가적인 정보를 전달해야 한다 → sealed class / 아니다 → null

| **구분** | **null (Nullable)** | **Sealed Class (Failure)** |
| --- | --- | --- |
| **맥락 (Context)** | 실패 이유가 너무 자명할 때 
(예: `list.find { ... }` 결과 없음) | 실패 이유가 다양할 때 
(예: 타임아웃, 인증 실패, 500 에러 등) |
| **연쇄 작업** | `?.` (Safe Call)이나 `?:` (Elvis)로 
가볍게 처리를 넘겨야 할 때 | 실패 사유에 따라 로직을 분기하거나 
서로 다른 후속 조치가 필요할 때 |
| **도메인 의미** | "값이 없음" 자체가 비즈니스적으로 
자연스럽고 유효한 데이터일 때 | "작업의 실패"를 명시적으로 기록(Logging)하거나 
상위 레이어에 전파해야 할 때 |
