# 아이템 3 - 최대한 플랫폼 타입을 사용하지 말라

- 코틀린의 주요 기능 중 하나인 `null-safety` 는 다른 Java, C 등 연결해서 사용할 때 문제가 발생할 수 있다. (Null-Pointer Exception, NPE)
- 자바는 @NotNull 애너테이션이 붙어있다면 이 애너테이션을 믿고 코틀린에서는 not null 하게 타입을 선언할 것이지만, 애너테이션이 없다면 ?
    - 자바에서는 모든 것이 nullable 하기 때문에 코틀린에서도 모두 nullable 하게 생각하는 게 안전할 수도 있다.
    - but, 어떤 것이 널이 아닌지 확실하게 알고 있는 경우에 `!!` 를 붙이게 된다.
    - 자바의 제네릭 타입을 가져오게 될 때 널이 아님을 단언 + null 필터링을 해야 한다.

→ 따라서, 자바의 널 여부가 확인되지 않는 타입을 널 가능 타입으로 처리하는 대신에 특별한 타입으로 처리하는 것을 `플랫폼 타입`

- 플랫폼 타입은 `String!` 과 같이 이름 뒤에 느낌표 하나로 표기한다.
    - 플랫폼 타입을 직접적으로 명시할 수는 없고, 널 가능 혹은 널 불가능 타입으로 지정해 해당 값을 처리할 수 있다.
    
    ```java
    // java
    
    public class UserRepo {
       public User getUser() 
    }
    ```
    
    ```kotlin
    // kotlin 
    
    val repo = UserRepo()
    val user1 = repo.user        // User!
    val user2: user = repo.user  // User
    val user3: User? = repo.user // User?
    ```
    
- 타입 캐스팅 보다는 낫지만, null 이 될 수 없다고 가정한 것이 미래에 null 이 될 수 있으니 NPE 를 주의해야 한다.

```java
// java

public class JavaClass {
   public String getValue() {
      return null;
   }
}
```

```kotlin
// Kotlin

fun statedType() {
   val value: String = JavaClass().value
   println(value.length)
}

fun platformType() {
   val value = JavaClass().value
   println(value.length)
}
```

- statedType 은 value 값을 가져오는 곳에서 NPE, platformType 은 println 통해 값을 사용할 때 에러
    - 추후에 코드가 확장된다면 더 위험!
- 해당 코드(플랫폼 타입)을 제거하거나, 자바 코드(생성자, 메서드, 필드) 에 nullable 여부 지정 어노테이션`(@nullable`) 달기
