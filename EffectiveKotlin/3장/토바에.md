# 아이템 3 - 최대한 플랫폼 타입을 사용하지 말라

### 코틀린의 주요 기능

- null-safety (널 안정성)
    - 자바에서 자주 볼 수 있던 Null-Pointer Exception(NPE)를 코틀린에서는 거의 찾아보기 힘들다
    - null-safety 메커니즘을 사용하지 않는 자바, C 등의 언어와 코틀린을 연결해서 사용하면 예외가 발생할 수 있다

### 자바에서 String 타입을 반환하는 메서드를 코틀린에서 사용하기

- `@Nullable` 어노테이션 → `String?` 타입으로 변경
- `@NotNull` 어노테이션 → `String` 타입으로 변경
- 어노테이션이 없을 때 → nullable로 가정
- null을 확실하게 리턴하지 않을 때 → `!!` non-null

nullable과 관련해 자주 문제가 되는 부분 = 자바의 제네릭 타입

### 자바 API에서 List<User>를 반환하고 어노테이션이 없을 때

- List 요소에 null이 있는지 확인해야 함
- User 객체들이 null이 아니라는 것도 알아야 함

```kotlin
public class UserRepo {
 public List<User> getUser() {
  // ...
 }
}
```

```kotlin
val users: List<User> = UserRepo().users!!.filterNotNull()
```

### 만약 함수가 List<List<User>>을 반환할 때

```kotlin
public class UserRepo {
 public List<List<User>> getUser() {
  // ...
 }
}
```

```kotlin
val users: List<List<User>> = UserRepo().groupedUsers!!.map { it!!.filterNotNull() }
```

→ 리스트는 map과 filterNotNull 등의 메서드를 제공하지만, 다른 제네릭 타입이라면 널을 확인하는 것 자체가 복잡함

### 플랫폼 타입 (platform type)

- 자바 등 다른 언어에서 넘어온 타입
- 타입 이름 뒤에 `!` 기호를 붙여서 표기
- 직접 코드에 나타내지는 않음
- 다음 중 선택적으로 사용

```kotlin
public class UserRepo {
	public User getUser() {
		// ...
	}
}
```

```kotlin
val repo = UserRepo()
val user1 = repo.user // User! 타입
val user2: User = repo.user
val user3: User? = repo.user
```

- 보이지 않는 위험
    - null이 아니라고 생각되는 것이 null일 가능성이 있음
- 플랫폼 타입을 사용할 때는 조심해야 함
- 설계자가 명시적으로 어노테이션으로 표시하거나 주석으로 달아두지 않으면 동작이 변경될 수 있음
    - 지금 당장 null을 반환하지 않아도 미래에는 변경될 수 있다는 점을 염두해 둬야 함
- 자바와 코틀린을 함께 사용할 때, 자바를 직접 조작할 수 있다면 `@Nullable` 과 `@NotNull` 어노테이션을 사용 권장

```kotlin
import org.jetbrains.annotation.NotNull;

public class UserRepo {
	public @NotNull User getUser() {
		// ...
	}
}
```

### 플랫폼 타입을 빨리 제거해야 하는 이유

```kotlin
public class JavaClass {
	public String getValue() {
		return null;
	}
}
```

```kotlin
fun statedType() {
	val value: String = JavaClass().value
	println(value.length)
}

fun platformType() {
	val value = JavaClass().value
	println(value.length)
}
```

- `statedType()`와 `platformType()`에서 NPE 발생
- `statedType()`에서는 `val value: String = JavaClass().value` 값을 가져올 때 NPE 발생
    - 비교적 코드 수정이 쉬움
- `platformType()` 에서는 `println(value.length)` 값을 활용할 때 NPE 발생

### 인터페이스에서 플랫폼 타입을 사용할 때

```kotlin
interface UserRepo {
	fun getUserName() = JavaClass().value
}
```

- 해당 메서드는 inferred 타입 (추론된 타입)이 플랫폼 타입
- 누구나 nullable 여부를 지정 가능 → 누구는 nullable로 반환하게, 누군가는 non-null로 반환

```kotlin
class RepoImpl: UserRepo {
	override fun getUserName(): String? {
		return null
	}
}
	
fun main() {
		val repo: UserRepo = RepoImpl()
		val text: String = repo.getUserName() // 런타임에 NPE 발생
		print("User name length is ${text.length}")
}
```

- 플랫폼 타입이 다른 곳에 전파됨 ⇒ 매우 위험
- 인텔리제이에서는 추론된 타입이 플랫폼 타입일 때, 경고문을 띄워줌
