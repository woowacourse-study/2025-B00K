# 최대한 플랫폼 타입을 사용하지 말라

## Null-Safety와 다른 언어와의 상호운용

코틀린의 주요 기능 중 하나는 Null-Safety입니다. 하지만 Null-Safety 메커니즘이 없는 자바, C 등의 프로그래밍 언어와 코틀린을 연결해서 사용할 때는 `NullPointerException`이 발생할 수 있습니다.

### 자바 메서드의 null 처리

예를 들어 자바에서 String 타입을 리턴하는 메서드가 있다고 가정해봅시다.

- `@Nullable` 어노테이션이 붙어 있다면 이를 nullable로 추정하고 `String?`으로 변환합니다.
- `@NotNull` 어노테이션이 붙어 있다면 `String`으로 변환합니다.

하지만 어노테이션이 붙어 있지 않다면 어떻게 될까요?

```java
public class JavaTest {
    public String giveName() {}
}
```

자바에서는 모든 것이 nullable일 수 있으므로, 최대한 안전하게 접근한다면 이를 nullable로 가정해야 합니다. 하지만 어떤 메서드는 null을 리턴하지 않을 것이 확실할 수 있어, 이 경우 `!!` 연산자를 사용하기도 합니다.

### 제네릭 타입의 문제

nullable과 관련하여 자주 문제가 되는 부분은 자바의 제네릭 타입입니다.

```java
// 자바
public class UserRepo {
    public List<User> getUsers() {}
}
```

```kotlin
// 코틀린
val users: List<User> = UserRepo().users!!.filterNotNull()
```

코틀린에서는 리스트 자체가 null인지, 그리고 리스트 내부 요소들이 null인지 알 수 없기 때문에 `filterNotNull()` 메서드를 사용해 내부 요소들의 null을 확인해야 합니다. 리스트는 이러한 메서드를 제공하지만, 이를 제공하지 않는 컬렉션의 경우 처리가 굉장히 복잡해집니다.

## 플랫폼 타입

코틀린은 이러한 다른 플랫폼의 타입들을 특수하게 다루며, 이를 **플랫폼 타입**이라고 부릅니다.

플랫폼 타입은 `String!`처럼 타입 이름 뒤에 `!` 기호를 붙여 표현하지만, 직접적으로 코드에 작성할 수는 없고 선택적으로 사용됩니다.

```java
// 자바
public class UserRepo {
    public User getUser() {}
}
```

```kotlin
// 코틀린
val repo = UserRepo()
val user1 = repo.user          // User! (플랫폼 타입)
val user2: User = repo.user    // User (non-null로 간주)
val user3: User? = repo.user   // User? (nullable로 간주)
```

이를 통해 앞서 살펴봤던 null 불안정성에 대한 문제가 해결됩니다.

```kotlin
val users: List<User> = UserRepo().users
```

## 정리

플랫폼 타입은 편리하지만, null이 아니라고 생각되는 것이 실제로는 null일 가능성이 있으므로 여전히 위험성이 존재합니다. 따라서 플랫폼 타입을 사용할 때는 항상 주의를 기울여야 합니다.

설계자가 명시적으로 어노테이션이나 주석으로 표시하지 않으면, 언제든 의도한 동작이 변경될 가능성이 있습니다. 함수가 지금 당장 null을 리턴하지 않더라도 미래에는 변경될 수 있다는 가능성을 항상 염두에 두어야 합니다.

**권장사항**: 가능한 한 자바 코드에 `@Nullable`과 `@NotNull` 어노테이션을 명시적으로 추가하여 플랫폼 타입의 사용을 최소화하는 것이 좋습니다.
