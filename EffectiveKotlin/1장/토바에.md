# 아이템1 - 가변성을 제한하라

코틀린에서는 모듈로 프로그램을 설계함

모듈

- 클래스
- 객체
- 함수
- 타입 별칭 (type alias)
- 최상위 프로퍼티
- (등등 그 외 다양한 요소로 구성됨)

모듈을 구성하는 요소 중 일부는 상태를 가질 수 있다.

- 읽기-쓰기가 가능한 var 프로퍼티 사용 `var a = 10`
- 가변 객체로 구성 `val list: MutableList<Int> = mutableListOf()`

요소가 상태를 갖는 경우 → 해당 요소가 작동하는 방식은 사용 방법뿐 아니라 요소의 이전 기록에 따라서도 달라짐

상태를 가진 클래스의 전형적인 예

- 잔액(상태)를 갖고 있는 은행 계좌(클래스)

```markdown
class BankAccount {
    var balance = 0.0
        private set
    
    fun deposit(depositAmount: Double) {
        balance += depositAmount
    }
    
    @Throws(InsufficientFunds::class)
    fun withdraw(withdrawAmount: Double) {
        if (balance < withdrawAmount) {
            throw InsufficientFunds()
        }
        balance -= withdrawAmount
    }
}

class InsufficientFunds: Exception()

fun main() {
    val account = BankAccount()
    println(account.balance) // 0.0
    account.deposit(100.0)
    println(account.balance) // 100.0
    account.withdraw(50.0)
    println(account.balance) // 50.0
}
```

- `BankAccount` 는 계좌에 돈이 얼마나 있는지를 나타내는 상태(`balance`)를 가지고 있음

상태를 가진다 = 양날의 검

- 장점: 시간에 따라 변화하는 요소를 표현
- 단점
    - 변경 지점이 많다
        - 이해하기 어렵다
        - 디버깅하기 어렵다
        - 변화를 추적하기 어렵다 → 가변 대상들 사이의 관계를 이해해야 함
        - 서로 의존하는 변경 지점이 많은 클래스는 이해하고 수정하기 어렵다
    - 가변성으로 코드를 추론하기 어렵다
        - 가변 상태(언제든 변경될 수 있는 값)은 값이 무엇인지 추론하기 어렵다
        - 방금 전에 확인한 값이 이미 변경된 상태일 수 있음
    - 가변 상태는 멀티스레드 프로그램에서 적절히 동기화되어야 한다
        - 모든 변화는 잠재적으로 충돌을 일으킬 수 있다
    - 가변 요소는 테스트하기 어렵다
        - 변경 지점들이 많을수록 테스트는 기하급수적으로 증가한다
    - 상태가 변경되면 다른 클래스에 이 변경사항을 알려야 하는 경우가 많다
        - 정렬된 리스트에 가변 요소를 추가하면, 이 요소가 변경될 때마다 리스트를 다시 정렬해야 함

# 코틀린에서 가변성 제한하기

코틀린은 가변성을 제한할 수 있다

- 불변 객체를 만들기
- 프로퍼티를 변경할 수 없게 만들기

이를 가능하게 하는 코틀린의 기능과 특징 중 중요한 것들

1. 읽기 전용 프로퍼티 `val`
2. 가변 컬렉션과 읽기 전용 컬렉션의 구분
3. 데이터 클래스의 `copy`

## 읽기 전용 프로퍼티

- 읽기 전용 프로퍼티는 값을 새로 설정할 수 없다

```markdown
val a = 10
a = 20 // 에러
```

- 읽기 전용 프로퍼티가 반드시 변경 불가능하거나 final (값을 재할당 할 수 없다) 이어야 하는 건 아니다 → 읽기 전용 프로퍼티에 가변 객체를 할당할 수 있다

```markdown
val list = mutableListOf(1, 2, 3)
list.add(4)
```

- 다른 프로퍼티에 의존하는 사용자 정의 게터를 사용해서 정의할 수 있다

```markdown
var name: String = "jiwon"
var surname: String = "pakr"
val fullName
	get() = "$name $surname"
	
fun main() {
	println(fullName) // jiwon park
	name = "ji won"
	println(fullName) // ji won park
}
```

코틀린에서 프로퍼티들은 기본적으로 캡슐화되어 있고 사용자 정의 접근자(게터와 세터)를 가질 수 있다는 점은 매우 중요함

→ API를 변경하거나 정의할 때 유연성을 제공

var는 게터이자 세터이므로 val을 var로 오버라이드 할 수 있다

```markdown
interface Element {
	val active: Boolean
}

class ActualElement : Element {
	override var active: Boolean = false
}
```

- val는 변경 불가능함을 의미하지 않는다
- val는 게터나 위임에 의해 정의될 수 있다

```markdown
val name: String? = "jiwon"
val surname: String = "park"

val fullName: String?
    get() = name?.let { "$it $surname" }

val fullName2: String? = name?.let { "$it $surname" }

fun main() {
    if (fullName != null) {
        println(fullName.length) // error
    }
    
    if (fullName2 != null) {
        println(fullName2.length) // 10
    }
}
```

fullName은 게터를 사용하고 있어 스마트 캐스팅이 불가능 → 사용 중에도 다른 값이 반환될 수 있음

- 논로컬 프로퍼티는 final이면서 사용자 정의 게터가 없을 경우에만 스마트 캐스팅을 할 수 있다

## 가변 컬렉션과 읽기 전용 컬렉션의 구분

읽기 전용 컬렉션 인터페이스

- Iterable
- Collection
- Set
- List

가변 컬렉션 인터페이스 → 각각 상응하는 읽기 전용 인터페이스를 상속해 변경을 허용하는 메서드를 추가함

- MutableIterable
- MutableCollection
- MutableSet
- MutableList

읽기 전용 컬렉션을 반드시 변경할 수 없는 것은 아니다

- 종종 변경 가능하지만 읽기 전용 인터페이스 뒤에 숨겨져있어 변경할 수 없음

→ Iterable<T>.map과 Iterable<T>.filter 기능들은 ArrayList를 읽기 전용 인터페이스인 List로 변환

컬렉션을 불변하게 만드는 것이 아니라 컬렉션 인터페이스만 읽기 전용으로 설계한 것은 더 많은 유연성을 제공함

- 내부적으로 반환하는 컬렉션의 실제 형태와 상관없이 인터페이스를 구현하기만하면 되므로 플랫폼별로 각각에 특화된 컬렉션을 사용할 수 있음

유일한 위험

- 개발자가 다운캐스팅을 해서 시스템을 해킹할 때 발생

```markdown
val list = listOf(1, 2, 3)

// Don't
if (list is MutableList) {
    list.add(4)
}
```

- 이 코드의 실행 결과는 플랫폼에 따라 달라진다
    - JVM에서 listOf는 자바의 List 인터페이스르 구현한 Arrays.ArrayList를 반환
    - 자바의 List인터페이스에는 add나 set 같은 인터페이스가 있으므로 코틀린에서 MutableList 인터페이스로 변환됨 → 그런데, Arrays.ArrayList는 add 등의 객체를 변경하는 연산을 구현하지 않음

⇒ 읽기 전용 컬렉션을 가변 컬렉션으로 다운캐스팅하면 안 된다.

필요하다면 수정할 수 있는 복사본을 생성하는 List.toMutableList()를 사용해야 함

```markdown
val list = listOf(1, 2, 3)

val mutablelist = list.toMutableList()
mutableList.add(4)
```

- 해당 방식은 어떤 규약도 위반하지 않으며 컬렉션을 List로 반환하면 외부에서 수정되지 않을 거라는 확신을 주기 때문에 안전함

## 데이터 클래스의 copy

불변 객체를 선호하는 이유

- 한 번 생성되면 상태가 동일하게 유지되므로 상태를 추론하기 쉬움
- 공유되는 객체들 간의 충돌이 발생하지 않아 프로그램을 병렬화하기 쉬움
- 불변 객체에 대한 참조는 변경되지 않을 것이므로 캐싱 가능
- 불변 객체에 대한 방어적 복사를 만들 필요가 없음 → 불변 객체를 복사할 때는 깊은 복사를 할 필요가 없음
- 불변 객체를 Set에 추가하거나 Map의 키로 사용할 수 있음 → 가변 객체에서는 하면 안 됨

```markdown
val names: SortedSet<FullName> = TreeSet()
val person = RullName("AAA", "AAA")
names.add(person)
names.add(FullName("BBB", "BBB"))
names.add(FullName("CCC", "CCC"))
    
print(names) // [AAA AAA, BBB BBB, CCC CCC]
print(person in names) // true

person.name = "ZZZ"
print(names) // [ZZZ AAA, BBB BBB, CCC CCC]
print(person in names) // false
```

- person에 이 Set에 있음에도 컬렉션은 false를 반환함 → 찾는 값의 해시 값이 달라졌기 때문

가변 객체는 위험하고 예측하기 어렵다

불변 객체는 데이터가 때때로 변경되어야 한다

→ 해결 방법 = 불변 객체가 변경 사항을 반영한 새로운 사본을 생성한느 메서드를 갖는 것

```markdown
class User(
    val name: String,
    val surname: String
) {
    fun withSurname(surname: String) = User(name, surname)
}

var user = User("AAA", "AAA")
user = user.withSurname("BBB")
        
print(user) // User(name=AAA, surname=BBB)
```

프로퍼티마다 복사본을 생성하는 함수를 만들 수는 있지만, 모든 프로퍼티에 적용해야 하면 귀찮은 작업임 → data 한정자를 사용

- data 한정자는 copy 메서드를 만들어줌
    - 모든 기본 생성자의 프로퍼티가 이전 인스턴스와 동일한 새 인스턴스를 생성하게 함
    - 프로퍼티에 새로운 값 지정도 가능

```markdown
data class User(
    val name: String,
    val surname: String
)

var user = User("AAA", "AAA")
user = user.copy(surname = "BBB")

print(user) // User(name=AAA, surname=BBB)
```

- 효율성은 떨어지지만 더 안전함
- 불변 객체가 가진 다른 모든 장점을 가짐

## 다른 종류의 변경 지점

변경할 수 있는 리스트를 나타내는 두 가지 방식

1. 가변 컬렉션 사용
2. 읽기-쓰기가 가능한 var 프로퍼티 사용

```markdown
val list1: MutableList<Int> = mutableListOf()
var list2: List<Int> = listOf()
```

- 둘 다 수정이 가능하지만 방법이 다르다

```markdown
list1.add(1)
list2 = list2 + 1
```

- 두 방식 모두 += 연산자로 대체해서 사용할 수 있지만, 각각에 대해 다르게 처리됨

```markdown
list1 += 1 // list1.plusAssign(1)
list2 += 1 // list2.plus(1)
```

- 하나의 변경 지점을 가지만 위치가 다름
- 첫 번째는 구체적인 리스트 구현체 내에서 변경이 발생
    - 멀티스레드를 사용한다면 컬렉션이 적절한 동기호 ㅏ기법을 가지고 있어야 정상적을 ㅗ동작함
- 두 번째 방식은 동기화를 직접 구현해야 함
    - 변경지점이 프로퍼티 하나이므로 안정성 측면에서 더 나음
    - 적절한 동기화 처리가 부족하면 여전히 일부 요소가 손실 될 수 있음

```markdown
var list = listOf<Int>()
    for (i in 1..1000) {
        thread {
            list = list + 1
        }
    }
    Thread.sleep(1000)
    print(list.size) // 1000이 아닌 9XX 값이 나온다 -> 중간에 값이 손실됨
```

가변 리스트 대신 가변 프로퍼티를 사용한다면 사용자 정의 게터를 정의하거나 위임을 활용해서 해당 프로퍼티의 변경을 추적할 수 있음 → observable 위임을 사용해서 다음과 같이 리스트의 모든 변경에 대해 로그를 남길 수 있음

```markdown
var names by obserable(listOf<String>()) { _, old, new ->
        prlintln("Names changed from $old to $new")
    }
    
names += "Fabio" // Names changed from [] to [Fabio]
names += "Bill" // Names changed from [] to [Fabio, Bill]
```

가변 컬렉션에 대해 이 기능을 구현하려면 해당 컬렉션이 원소 변화를 관찰 가능할 수 있도록 구현해야 함

- 가변 프로퍼티에 할당한 읽기 전용 컬렉션이 변경 사항을 더 쉽게 제어할 수 있음
- 여러 메서드 대신 하나의 세터만 두면 되기 때문
- 세터 또한 private으로 만들면 된다

```markdown
var announcements = listOf<Announment>()
    private set
```

가변 컬렉션을 사용하는 것이 더 빠를 수 있지만, 가변 프로퍼티를 사용하면 객체 변경을 제어하기 더 쉽다

```markdown
// Don't -> 최악
var list3 = mutableListOf<Int>()
```

결론

- 불필요한 가변 상태를 만들지 말자
- 모든 가변 상태는 비용임을 기억하자
- 모든 변경 지점을 이해하고 유지 관리해야 한다
