# 1장 - 가변성을 제한하라

코틀린은 **모듈**로 프로그램을 설계합니다.

### 모듈의 구성요소
- 클래스 (Classes)
- 객체 (Objects)
- 함수 (Functions)
- Type Alias
- Top-level Property

### 상태를 갖는 요소의 특징
상태를 갖는 요소는 **사용 방법**뿐만 아니라 **이력(history)**에도 의존합니다.

```kotlin
class BankAccount {
    var balance = 0.0
        private set
    
    fun deposit(depositAmount: Double) {
        balance += depositAmount
    }
    
    fun withdraw(withdrawAmount: Double) {
        if (balance < withdrawAmount) {
            throw InsufficientFundsException()
        }
        balance -= withdrawAmount
    }
}

class InsufficientFundsException : Exception()

// 사용 예시
val account = BankAccount()
println(account.balance)  // 0.0
account.deposit(100.0)
println(account.balance)  // 100.0
account.withdraw(50.0)
println(account.balance)  // 50.0
```

---

## 가변성의 문제점

### 1. 프로그램 이해 및 디버깅의 어려움
- 상태들 간의 관계를 파악해야 함
- 상태 변경이 많아질수록 추적이 어려워짐
- 예측 불가능한 동작 발생 가능

### 2. 멀티스레드 환경에서의 동기화 문제

#### 문제 상황: 가시성 문제
```kotlin
var num = 0
for (i in 1..1000) {
    thread {
        Thread.sleep(1000)
        num += 1
    }
}

Thread.sleep(5000)
print(num)  // 1000이 아닐 확률이 매우 높음!
```

#### 코루틴 사용 (부분적 개선)
```kotlin
suspend fun main() {
    var num = 0
    coroutineScope {
        for (i in 1..1000) {
            launch {
                delay(1000)
                num += 1
            }
        }
    }
    
    Thread.sleep(5000)
    print(num)
}
```
> **참고**: 코루틴을 사용하면 더 적은 스레드가 관여되므로 충돌 문제가 감소하지만, 여전히 `@Volatile` 같은 어노테이션이 필요할 수 있습니다.

### 3. 상태 변경 시 알림 필요
정렬된 리스트에 가변 요소를 추가하는 경우:
- 요소 변경 시마다 리스트 전체를 재정렬해야 함 (O(n) 복잡도)
- 성능 저하 및 복잡성 증가

> **핵심**: 가변성은 신중하고 확실하게 결정하고 사용하자!

---

## 코틀린에서 가변성 제한하기

### 1. 읽기 전용 프로퍼티 (`val`)

코틀린의 프로퍼티는 기본적으로 캡슐화되어 있고, 사용자 정의 접근자를 가질 수 있습니다.

| 키워드 | 포함 요소 |
|--------|-----------|
| `val`  | getter, field |
| `var`  | getter, setter, field |

> **주의**: `val`은 읽기 전용이지만 불변(immutable)은 아닙니다!

#### 스마트 캐스팅과 val

```kotlin
val name: String? = "Marton"
val surname: String? = "Braun"

// 스마트 캐스팅 불가
val fullName: String?
    get() = name?.let { "$it $surname" }

// 스마트 캐스팅 가능
val fullName2: String? = name?.let { "$it $surname" }
```

**이유**: 
- `fullName`은 게터로 정의되어 값을 사용하는 시점의 `name`에 따라 다른 결과 가능
- `fullName2`는 final 프로퍼티이고 커스텀 게터가 없어 스마트 캐스트 가능

### 2. 가변 컬렉션 vs 읽기 전용 컬렉션

| 종류 | 특징 |
|------|------|
| 읽기 전용 컬렉션 | `List`, `Set`, `Map` |
| 가변 컬렉션 | `MutableList`, `MutableSet`, `MutableMap` |

- `Mutable` 인터페이스는 읽기 전용 인터페이스를 상속받아 변경 메서드를 추가
- 예: `Iterable`의 `map`, `filter` 함수는 변경 가능한 `ArrayList`를 리턴

### 다운캐스팅의 위험성

```kotlin
val list = listOf(1, 2, 3)

if (list is MutableList) {
    list.add(4)  // 위험!
}
```

#### 문제의 원인

<img width="461" height="194" alt="image" src="https://github.com/user-attachments/assets/e0ae3ea6-0aa6-461e-ab4b-842eea4f66a7" />

**JVM의 `listOf()` 구현**:
```
java.util.ArrayList 
→ add(), remove(), set() 가능 (변경 가능한 자료구조)

java.util.Arrays.ArrayList 
→ add(), remove(), set() 불가능 (배열을 List처럼 감싼 것, 크기 변경 불가)
```

자바의 `List` 인터페이스는 `add`와 `set` 메서드를 제공하지만, `Arrays.ArrayList`는 이를 구현하지 않아 런타임 에러 발생!

<img width="621" height="125" alt="image" src="https://github.com/user-attachments/assets/bc075991-bb0d-4b8f-b645-58e737abd7ef" />

#### 올바른 방법: 복사를 통한 변환

```kotlin
val list = listOf(1, 2, 3)
val mutableList = list.toMutableList()
mutableList.add(4)  // 안전!
```

### 3. Data Class의 `copy()`

불변 객체를 수정할 때는 `copy()` 메서드를 사용하여 새로운 인스턴스를 생성합니다.

```kotlin
data class User(val name: String, val age: Int)

val user1 = User("Alice", 25)
val user2 = user1.copy(age = 26)  // 새로운 인스턴스 생성
```

---

## 불변 객체의 장점

### 주요 이점

| 장점 | 설명 |
|------|------|
| **이해하기 쉬움** | 한 번 정의된 상태가 유지되어 코드 추적이 용이 |
| **스레드 안전** | 공유 시에도 충돌이 없어 병렬 처리가 안전 |
| **캐싱 가능** | 참조가 변경되지 않아 쉽게 캐시 가능 |
| **방어적 복사 불필요** | 불변이므로 복사본을 만들 필요 없음 |
| **Hash 키로 사용 가능** | `HashSet`, `HashMap` 등의 키로 안전하게 사용 |

---

## 변경 가능 지점 관리

### 두 가지 변경 방식의 차이

```kotlin
// 방식 1: MutableList 사용
val list1 = mutableListOf<Int>()
list1.add(1)  // 내부 상태 변경

// 방식 2: 불변 리스트 + var 프로퍼티
var list2 = listOf<Int>()
list2 = list2 + 1  // 프로퍼티 자체를 재할당
```

#### MutableList의 변경 가능 지점
- **구체적인 리스트 구현 내부**에 변경 가능 지점 존재
- 멀티스레드 환경에서 적절한 동기화가 없으면 위험

#### 불변 List + var의 변경 가능 지점
- **프로퍼티 자체**가 변경 가능 지점
- 더 예측 가능하고 추적하기 쉬움

---

## 변경 가능 지점 노출하지 말기

### 나쁜 예시: Private 상태 노출

```kotlin
data class User(val name: String)

class UserRepository {
    private val storedUsers: MutableMap<Int, String> = mutableMapOf()

    fun loadAll(): MutableMap<Int, String> = storedUsers  // 위험!
}
```

**문제점**:
```kotlin
val repo = UserRepository()
val storedUsers = repo.loadAll()
storedUsers[4] = "peto"  // private 상태를 외부에서 수정!
```

### 해결 방법

#### 방법 1: 방어적 복제

```kotlin
class UserRepository {
    private val storedUsers: MutableMap<Int, String> = mutableMapOf()

    fun loadAll(): MutableMap<Int, String> = storedUsers.toMap()  // 복사본 반환
}
```

#### 방법 2: 읽기 전용 슈퍼 타입으로 업캐스팅

```kotlin
class UserRepository {
    private val storedUsers: MutableMap<Int, String> = mutableMapOf()

    fun loadAll(): Map<Int, String> = storedUsers  // 읽기 전용 타입 반환
}
```

</div>
