## 1장 좋은 코드
### 1. 가변성을 제한하라

- 모듈(클래스, 객체, 함수 etc…)에서는 **상태(state)**를 가질 수 있음.
    
    ```jsx
    var a = 10
    var list: MutableList<Int> = mutableListof()
    ```
    
    - 하지만, **상태를 적절하게 관리하는 것이 생각보다 어려움**
        1. 프로그램 이해하고 디버깅 어렵다.
            - 상태 갖는 부분의 관계를 이해해야 한다.
            - 예상치 못한 오류 발생시킬 경우 큰 문제가 된다.
        2. 코드의 실행 추론하기 어려워진다.
            - 1번과 같은 맥락인 것 같은데, 시점에 따라서 값이 달라져 코드 실행을 예측하기 어렵다.
        3. 멀티스레드 프로그램일 경우, 적절한 동기화 필요하다.
            - 변경이 생기면 충돌 발생이 우려된다.
        4. 테스트하기 어렵다.
            - 모든 상태를 테스트해야 하기에, 변경이 많을수록 더 많은 조합으로 테스트 해야한다.
        5. 상태 변경 시 다른 부분에 알려야 하는 경우가 있다.
            - 정렬되어 있는 리스트에 새로운 요소 추가 시, 요소 변경 일어날 때마다 리스트 전체 다시 정렬해야 한다.
        - 가변성은 단점이 많아서 순수 함수형 언어도 있다 → 하스켈(Haskell)
    - 이렇듯, 시스템 상태 나타내기 위한 방법 중 하나이지만, 변경 일어나야 하는 부분을 신중하고 확실하게 결정해서 사용하자
- **가변성 제한하기**
    - **읽기 전용 프로퍼티(val)**
        
        ```kotlin
        val a = 10
        a = 20 // 오류
        ```
        
        - 위 코드처럼 선언해서 사용가능한 읽기 전용 프로퍼티 값(Value)
        - 완전히 변경 불가능한 것은 아님!
            1. `mutable` 객체를 담고 있다면, 내부적으로 변할 수 있다.
            
            ```kotlin
            val list = mutableListOf(1,2,3)
            list.add(4)
            
            print(list) // [1,2,3,4]
            ```
            
            1. 다른 프로퍼티 활용하는 `getter` 로도 변할 수 있다.
            
            ```kotlin
            var name: String = "Myeongji"
            var familyName: String = "Son"
            val fullName
            	get() = "$familyName $name"
            	
            fun main() {
            	println(fullName) // Son Myeongji
            	name = "MJ"
            	println(fullName) // Son MJ
            ```
            
            → ‘프로퍼티를 읽을 수만 있다는 속성(읽기 전용)’과 ‘값이 변할 수 없는 것(가변성)’을 구분하자
            
            - more Property
                - 코틀린의 프로퍼티는 기본적으로 캡슐화 되어있다.
                    - 가시성 접근자
                    - 사용자 정의 접근자(getter/setter)
                        - var → getter/setter
                        - val → getter
                        
                        ⇒ 즉, val을 var로 오버라이딩 할 수 있다.
                        
                        ```kotlin
                        interface 사람 {
                        	val 나이: Int
                        } 
                        
                        class 학생: 사람 {
                        	override var 나이: Int = 23
                        }
                        ```
                        
    - 가변 컬렉션과 읽기 전용 컬렉션 구분하기
        
        <img width="1627" height="1245" alt="image" src="https://github.com/user-attachments/assets/b9490a53-d9a4-4297-b0f2-9adca5f06877" />

        
        - 읽기 전용 **컬렉션은 내부의 값을 변경할 수 있음**
        - `단,` 읽기 전용 **인터페이스**가 이를 지원하지 않으므로 변경할 수 없다.
        
        → **내부적으로 immutable 하지 않은 컬렉션을 외부적으로 immutable하게 보이게 만들어 안정성을 얻는다.**
        
    - **데이터 클래스의 copy**
        - data class → copy 메서드 제공
        
        ```kotlin
        // 기존
        class User(
            val name: String,
            val surname: String,
        ) {
            fun withSurname(surname: String) = User(name, surname)
        }
        
        var user = User("MJ", "son")
        user = user.withSurname("Soon")
        print(user) // User(name=MJ, surname=Soon)
        
        // 변경 (data class 사용)
        data class User1(
            val name: String,
            val surname: String,
        )
        
        var user1 = User1("mj", "son")
        user1 = user1.copy(surname = "mong")
        print(user1) // User1(name=mj, surname=mong)
        ```
        
- 변경 가능 지점
    
    ```kotlin
    val list1: MutableList<Int> = mutableListOf()
    var list2 = list2 + 1
    
    list1 += 1 // list1.plusAssign(1)
    list2 += 1  // list2 = list2.plus(1)
    ```
    
    - `Delegates.observable`
        
        ```kotlin
           var names by Delegates.observable(listOf<String>()) { _, old, new ->
                println("Names changed $old to $new")
            }
        
            names += "Fabio"
            names += "Bill"
            
            // Names changed [Fabio] to [Fabio, Bill]
        ```
        
    - 프로퍼티와 컬렉션을 모두 변경 가능한 지점으로 만들지 말라
        
        ```kotlin
        var list3 = mutableListOf<Int>()
        ```
        
        → 변경될 수 있는 두 지점 모두에 대한 동기화 구현해야 함.
        
        → 모호성 발생해서 += 사용 불가
        
- 변경 가능 지점 노출하지 말기
    
    <img width="1284" height="988" alt="image" src="https://github.com/user-attachments/assets/3d8909f0-3979-424d-84a1-6810f2975d00" />

    
    → 이렇게 될 경우 UserRepository 의 `storedUsers` 와 main 에서의 `storedUsers`  는 같게 됨. 즉, main 에서는 UserRepository의 storedUsers를 사용하고 있는 것이다.
    
    - 그렇다면 어떻게 해야할까?
        1. mutable 객체 복제하기 (방어적 복제) → `data class의 copy 사용`
        
        ```kotlin
        class UserHolder {
        	private val user: MutableUser()
        	
        	fun get(): MutableUser {
        		return user.copy() // 방어적 복사
        	}
        } 
        ```
        
        2. 가변성 제한하기 → 읽기 전용 타입으로 캐스트하기
        
        <img width="1670" height="956" alt="image" src="https://github.com/user-attachments/assets/6b28437b-7f6d-468e-954d-17102d775532" />

        
- 총 정리
    - var 보다는 val을 사용하자
    - mutable 보다는 immutable을 사용하자
    - 변경이 필요하다면 immutable 데이터 클래스를 만들고 `copy` 를 사용하자
    - 컬렉션에 상태를 저장해야 한다면, mutable 컬렉션 보다는 `읽기 전용 컬렉션`으로 사용하자
    - mutable 객체를 `외부에 노출`하지 말자
    
    → 즉, 가변성을 제한하라
