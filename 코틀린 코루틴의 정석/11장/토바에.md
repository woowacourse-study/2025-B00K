# 코루틴 심화

## 공유 상태를 사용하는 코루틴의 문제와 데이터 동기화

### 가변 변수를 사용할 때의 문제점

코드의 안정성을 높이기 위해 가변 변수 대신 불변 변수를 사용해야 한다.

스레드 간에 데이터를 전달하거나 공유된 자원을 사용하는 경우에는 가변 변수를 사용해 상태를 공유하고 업데이트해야 한다.

→ 여러 스레드에서 변수에 동시에 접근해 값을 변경하면 데이터의 손실이나 불일치로 인해 버그가 생긴다.

코루틴은 주로 멀티 스레드 환경에서 실행된다.

→ 코루틴을 사용할 때도 문제가 발생할 수 있다.

```jsx
var count = 0

fun main() = runBlocking<Unit> {
  withContext(Dispatchers.Default) {
    repeat(10_000) {
      launch {
        count += 1
      }
    }
  }
  println("count = ${count}")
}

/*
// 결과1:
count = 9145 // 매번 다른 값이 나온다.
// 결과2:
count = 9378 // 매번 다른 값이 나온다.
// 결과3:
count = 9421 // 매번 다른 값이 나온다.
*/
```

count를 0으로 초기화한 후 runBlocking 코루틴 내부에서 withContext(Dispatchers.Default)를 사용해 count의 값을 1씩 증가시키는 launch 코루틴을 1만 개 실행하고 실행 완료될 때까지 대기하도록 만든다.

Dispatchers.Default 객체는 멀티 스레드를 사용한다.

→ 1만 개의 코루틴이 count의 값에 접근하고 변경하는 작업은 병렬적으로 실행된다.

1만 개의 코루틴이 모두 완료되면 count의 값이 출력되고 종료된다.

1만 번 반복되지만, count는 10,000이 출력되지 않는다.

이런 문제 발생 원인 2가지

1. 메모리 가시성 문제
2. 경쟁 상태 문제

메모리 가시성 문제란?

- 스레드가 변수를 읽는 메모리 공간에 관한 문제
- CPU 캐시와 메인 메모리 등으로 이뤄지는 하드웨어의 메모리 구조와 연관돼 있다.

스레드가 변수를 변경시킬 때 메인 메모리가 아닌 CPU 캐시를 사용할 경우, CPU 캐시의 값이 메인 메모리에 전파되는 데 약간의 시간이 걸린다.

→ CPU 캐시와 메인 메모리 간에 데이터 불일치 문제가 생김

→ 다른 스레드에서 해당 변수를 읽을 때 변수가 변경된 것을 확인하지 못할 수 있음.

예시

하나의 스레드에서 count 변수의 값을 1000에서 1001로 변경시켰지만 CPU 캐시에만 반영되고 메인 메모리로 전파되지 않아 다른 스레드에서 count 변수에 접근했을 때 count 값이 1000이다.

경쟁 상태란?

2개의 스레드가 동시에 값을 읽고 업데이트 시키면 같은 연산이 두 번 일어난다.

→ 2개의 코루틴이 값을 1만큼만 증가시키므로 하나의 연산은 손실된다.

### JVM의 메모리 공간이 하드웨어 메모리 구조와 연결되는 방식

<img width="254" height="238" alt="스크린샷 2025-08-02 오후 4 22 59" src="https://github.com/user-attachments/assets/e6e15201-376f-4554-b074-2d6cb8340866" />

JVM은 스레드마다 스택 영역이라고 불리는 메모리 공간을 가지고 있다.

→ 원시 타입의 데이터 저장, 힙 영역에 저장된 객체에 대한 참조(주소값)이 저장된다.

힙 영역은 JVM 스레드에서 공통으로 사용되는 메모리 공간으로 객체나 배열 같은 크고 복잡한 데이터가 저장된다.

<img width="267" height="297" alt="스크린샷 2025-08-02 오후 4 25 02" src="https://github.com/user-attachments/assets/e94c9f44-8718-4003-ac7c-e1566334f61e" />

#### JVM이 실행되는 컴퓨터의 메모리 구조

각 CPU는 CPU 캐시 메모리를 둔다.

데이터 조회 시 공통 영역인 메인 메모리까지 가지 않고 CPU 캐시 메머리에서 데이터를 조회할 수 있도록 만들어 메모리 액세스 속도를 향상시킨다.

<img width="518" height="296" alt="스크린샷 2025-08-02 오후 4 26 54" src="https://github.com/user-attachments/assets/2ef34c76-91f9-4618-92c4-014f7ae67c8b" />


하드웨어 메모리 구조는 JVM의 스택 영역과 힙 영역을 구분하지 않는다.

→ JVM의 스택 영역에 저장된 데이터들은 CPU 레지스터, CPU 캐시 메모리, 메인 메모리 모두 나타날 수 있다.

→ 힙 영역도 동일하게 모두 나타날 수 있다.

⇒ 이러한 구조로 멀티 스레드 환경에서 공유 상태를 사용할 때 두 가지 문제가 발생한다.

1. 공유 상태에 대한 메모리 가시성 문제
2. 공유 상태에 대한 경쟁 상태 문제

### 공유 상태에 대한 메모리 가시성 문제와 해결 방법

#### 공유 상태에 대한 메모리 가시성 문제

- 하나의 스레드가 다른 스레드가 변겨오딘 상태를 확인하지 못하는 것
- 서로 다른 CPU에서 실행된느 스레드들에서 공유 상태를 조회하고 업데이트할 때 생기는 문제

<img width="269" height="279" alt="스크린샷 2025-08-02 오후 4 49 57" src="https://github.com/user-attachments/assets/e1ed4bfe-55ec-4a90-9733-49c901528a6c" />


1. 공유 상태는 처음에 메인 메모리상에 저장돼 있음
    
    <img width="252" height="309" alt="스크린샷 2025-08-02 오후 4 50 00" src="https://github.com/user-attachments/assets/17fcda94-50b3-4658-9596-22696cc8b5ac" />

    
2. 하나의 스레드가 이 공유 상태를 읽어오면 해당 스레드를 실행 중인 CPU는 공유 상태를 CPU 캐시 메모리에 저장함
    
<img width="260" height="310" alt="스크린샷 2025-08-02 오후 4 50 04" src="https://github.com/user-attachments/assets/49b45825-de97-46d2-bda7-a661a8a65de6" />

4. 연산이 완료되면 메인 메모리가 아닌 CPU 캐시 메모리에 저장
5. CPU 캐시 메모리의 변경된 값은 플러시가 일어나지 않으면 메인 메모리로 전파되지 않음.
    <img width="246" height="309" alt="스크린샷 2025-08-02 오후 4 50 08" src="https://github.com/user-attachments/assets/77ed3656-dca3-4c0c-96d8-0dbd682b90e9" />

6. 다른 CPU에서 실행되는 스레드에서 count 변수의 값을 읽는 스레드는 메인 메모리상의 값을 인식함.
7. 자신의 CPU 캐시 메모리에 저장함.
    <img width="245" height="314" alt="스크린샷 2025-08-02 오후 4 50 11" src="https://github.com/user-attachments/assets/c4a6d595-7810-4634-9de4-8fdead9db695" />

  
8. 메인 메모리로 플러시가 일어나면 연산은 두 번 일어나지만 count 값은 하나만 증가됨.

#### `@Volatile` 사용해 공유 상태에 대한 메모리 가시성 문제 해결하기

```jsx
@Volatile
var count = 0

fun main() = runBlocking<Unit> {
  withContext(Dispatchers.Default) {
    repeat(10_000) {
      launch {
        count += 1
      }
    }
  }
  println("count = ${count}")
}
/*
// 결과:
count = 8636
*/
```

`@Volatile` 어노테이션이 설정된 변수를 읽고 쓸 때는 CPU 캐시 메모리를 사용하지 않는다.

→ 메인 메모리를 사용한다.

스레드에서는 count 변수의 값을 메인 메모리에서 조회하고 값에 대한 변경 연산도 메인 메모리에서 직접 수행한다.

하지만 여전히 10000으로 나오지 않는다.

→ 여러 스레드가 메인 메모리의 count 변수에 동시에 접근할 수 있기 때문

### 공유 상태에 대한 경쟁 상태 문제와 해결 방법

#### 공유 상태에 대한 경쟁 상태 문제

경쟁 상태 문제 : 여러 스레드가 동시에 하나의 값에 접근하면서 발생하는 문제

각 launch 코루틴이 Dispatchers.Default 객체를 사용해 병렬로 실행되는 코루틴들이 count 변수의 값을 증가시킨다.

→ 각 스레드에서 실행 중인 코루틴들이 count 변수에 동시에 접근할 수 있음

→ 같은 연산이 중복으로 실행

⇒ 변수의 값은 한 번만 증가하지만, 실제 연산은 2번 실행

```jsx
@Volatile
var count = 0

fun main() = runBlocking<Unit> {
  withContext(Dispatchers.Default) {
    repeat(10_000) {
      launch {
        count += 1
      }
    }
  }
  println("count = ${count}")
}
/*
// 결과:
count = 8636
*/
```

어떻게 해결?

- 하나의 변수에 스레드가 동시에 접근할 수 없도록 만들어야 함

#### Mutex 사용해 동시 접근 제한하기

동시 접근 제한하는 간단한 방법

- 공유 변수의 변경 가능 지점을 임계 영역으로 만들어 동시 접근을 제한

코틀린에서는 코루틴에 대한 임계 영역을 만들기 위한 Mutex 객체를 제공한다.

- Mutex 객체의 lock 일시 중단 함수가 호출되면 락이 획득
- 해당 Mutex 객체에 대해 unlock이 호출돼 락이 해제될 때까지 다른 코루틴이 해당 임계 영역에 진입할 수 없음
- 공유 상태를 변경하는 부분을 임계 영역으로 만들면 해당 영역에 둘 이상의 코루틴이 접근할 수 없도록 만들 수 있음

```jsx
var count = 0
val mutex = Mutex()

fun main() = runBlocking<Unit> {
  withContext(Dispatchers.Default) {
    repeat(10_000) {
      launch {
        mutex.lock() // 임계 영역 시작 지점
        count += 1
        mutex.unlock() // 임계 영역 종료 지점
      }
    }
  }
  println("count = ${count}")
}
/*
// 결과:
count = 10000
*/
```

Mutex 객체를 사용해 락을 획득한 후에는 꼭 해제해야 함.

→ 해제하지 않으면, 해당 임계 영역은 다른 스레드에서 접근이 불가능하게 돼 문제를 일으킬 수 있음

withLock 일시 중단 함수를 호출하는 것이 안전하게 Mutex 객체를 사용할 수 있음

```jsx
var count = 0
val mutex = Mutex()

fun main() = runBlocking<Unit> {
  withContext(Dispatchers.Default) {
    repeat(10_000) {
      launch {
        mutex.withLock {
          count += 1
        }
      }
    }
  }
  println("count = ${count}")
}
/*
// 결과:
count = 10000
*/
```

왜 뮤텍스 기능을 하는 ReetranLock 객체 대신 Mutex 객체를 사용하는 것일까?

- Mutex 객체의 lock 함수는 일시 중단 함수

다른 코루틴에 의해 Mutex 객체에 락이 걸려 있으면 코루틴은 기존의 락이 해제될 때까지 스레드를 양보하고 일시 중단한다.

→ 스레드가 블로킹되지 않도록 해서 스레드에서 다른 작업이 실행될 수 있도록 한다.

이후 기존의 락이 해제되면 코루틴이 재개돼 Mutex 객체의 락을 획득한다.

- 코루틴에서 ReetranLock 객체에 대해 lock을 호출

이미 다른 스레드에서 락을 획득했다면 코루틴은 락이 해제될 때까지 lock을 호출한 스레드를 블로킹하고 기다린다.

→ lock을 호출한 스레드를 다른 코루틴이 사용할 수 없음

ReetranLock 객체를 사용하더라도 안전한 임계 영역을 만들 수 있는 것은 동일하다.

```jsx
var count = 0
val reentrantLock = ReentrantLock()

fun main() = runBlocking<Unit> {
  withContext(Dispatchers.Default) {
    repeat(10_000) {
      launch {
        reentrantLock.lock() // 스레드를 블록하고 기존의 락이 해제될 때까지 기다림
        count += 1
        reentrantLock.unlock()
      }
    }
  }
  println("count = ${count}")
}
/*
// 결과:
count = 10000
*/
```

#### 공유 상태 변경을 위해 전용 스레드 사용하기

스레드 간에 공유 상태를 사용해 생기는 문제점

- 복수의 스레드가 공유 상태에 동시에 접근할 수 있음

→ 하나의 전용 스레드만 사용하도록 강제하면 공유 상태에 동시에 접근하는 문제를 해결할 수 있음

하나의 전용 스레드만 사용할 수 있도록 만드는 방법

- newSingleThreadContext 함수를 사용해 단일 스레드로 구성된 CoroutineDispatcher 객체를 생성해 특정 연산을 위해 사용되도록 만들면 된다.

withContext 인자로 넘어가 count 변수의 값을 증가시킬 때 코루틴의 실행 스레드가 CountChangeThread로 전환되도록 강제한다

→ luanch 코루틴이 Dispatchers.Default를 통해 백그라운드 스레드에서 실행되더라도 increaseCount 일시 중단 함수가 호출되면 launch 코루틴의 실행 스레드가 CountChangeThread로 전환돼 count 변수에 대한 동시 접근이 일어나지 않는다.

```jsx
var count = 0
val countChangeDispatcher = newSingleThreadContext("CountChangeThread")

fun main() = runBlocking<Unit> {
  withContext(Dispatchers.Default) {
    repeat(10_000) {
      launch { // count 값을 변경 시킬 때만 사용
        increaseCount()
      }
    }
  }
  println("count = ${count}")
}

suspend fun increaseCount() = coroutineScope {
  withContext(countChangeDispatcher) {
    count += 1
  }
}
/*
// 결과:
count = 10000
*/
```

단일 스레드를 사용하기 위해 Dispatchers.IO.limitedParallelism(1)이나 Dispatchers.Default.limitedParallelism(1)을 사용할 수도 있음.

## 원자성 있는 데이터 구조를 사용한 경쟁 상태 문제 해결

경쟁 상태 문제 해결을 위해 원자성 있는 객체를 사용할 수 있다.

- AtomicInteger

```jsx
var count = AtomicInteger(0)

fun main() = runBlocking<Unit> {
  withContext(Dispatchers.Default) {
    repeat(10_000) {
      launch {
        count.getAndUpdate {
          it + 1 // count값 1 더하기
        }
      }
    }
  }
  println("count = ${count}")
}
/*
// 결과:
count = 10000
*/
```

원자성 있는 객체는 여러 스레드가 동시에 접근해도 한 번에 하나의 스레드만 접근할 수 있도록 제한한다.

복수의 코루틴이 병렬로 실행되더라도 특정 시점에 count에 대한 getAndUpdate 연산을 실행하는 코루틴은 하나뿐이다.

### 객체의 참조에 원자성 부여하기

AtomicReference 클래스를 사용하면 복잡한 객체의 참조에 대해 원자성을 부여할 수 있다.

```jsx
data class Counter(val name: String, val count: Int)
val atomicCounter = AtomicReference(Counter("MyCounter", 0)) // 원자성 있는 Counter 만들기

fun main() = runBlocking<Unit> {
  withContext(Dispatchers.Default) {
    repeat(10_000) {
      launch {
        atomicCounter.getAndUpdate {
          it.copy(count = it.count + 1) // MyCounter의 count값 1 더하기
        }
      }
    }
  }
  println(atomicCounter.get())
}
/*
// 결과:
Counter(name=MyCounter, count=10000)
*/
```

### 원자성 있는 객체를 코루틴에서 사용할 때의 한계

코루틴은 원자성 있는 객체에 접근할 때 이미 다른 스레드의 코루틴이 해당 객체에 대한 연산을 실행 중인 경우 코루틴은 스레드를 블로킹하고 연산 중인 스레드가 연산을 모두 수행할 때까지 기다린다.

→ 코루틴에서 ReetranLock 객체에 대해 lock을 사용하는 것과 비슷하다.

<aside>
💡

원자성 있는 객체를 코루틴에서 사용할 때는 원자성 있는 객체가 스레드를 블로킹시킬 수 있다는 점을 고려해 사용해야 한다.

</aside>

### 원자성 있는 객체를 사용할 때 많이 하는 실수

- 원자성 있는 객체의 읽기와 쓰기를 따로 실행하는 것

count에 대한 get 함수를 실행해 count 값을 가져온 후 count 값에 대해 set 함수를 실행해 get을 통해 가져온 값에 1을 더하고 있다. 이때 get 함수가 실행되고 나서 set 함수 실행 전에 다른 스레드에서 count에 대한 읽기 연산 또는 쓰기 연산을 실행할 수 있으므로 경쟁 상태 문제가 생긴다.

```jsx
var count = AtomicInteger(0)

fun main() = runBlocking<Unit> {
  withContext(Dispatchers.Default) {
    repeat(10_000) {
      launch {
        val currentCount = count.get()
        // 위 코드와 아래 코드의 실행 사이에 다른 스레드가 count의 값을 읽거나 변경할 수 있다.
        count.set(currentCount + 1)
      }
    }
  }
  println("count = ${count}")
}
/*
// 결과:
count = 8399
*/
```

원자성 있는 객체에 대한 읽기와 쓰기를 따로 사용하면 값이 변경되기 전에 다른 스레드에서 값에 대한 접근이 가능해진다.

→ 이를 해결하기 위해 getAndUpdate와 같은 읽기와 쓰기를 함께 실행하는 함수를 사용해야 한다.

getAndUpdate, incrementAndGet과 같은 함수들은 값을 읽고 쓸 동안 다른 스레드의 접근을 허용하지 않는다.

→ 모든 연산이 손실 없이 실행된다.

→ 원자성 있는 객체를 안전하게 사용하기 위해서는 하나의 스레드가 값을 읽고 쓸 동안 다른 스레드의 접근을 허용해서는 안 된다.

## CoroutineStart의 다양한 옵션들 살펴보기

코루틴에 실행 옵션을 주기 위해 launch나 async 등의 코루틴 빌더 함수의 start 인자로 CoroutineStart 옵션을 전달할 수 있다.

CoroutineStart의 옵션

1. CoroutineStart.DEFAULT
2. CoroutineStart.ATOMIC
3. CoroutineStart.UNDISPATCHED
4. CoroutineStart.LAZY

#### CoroutineStart.DEFAULT

launch의 start 인자로 아무런 값이 전달되지 않으면 기본 실행 옵션은 CoroutineStart.DEFAULT가 설정된다.

CoroutineStart.DEFAULT로 실행된 코루틴의 특징

- 코루틴 빌더 함수를 호출한 즉시 생성된 코루틴의 실행을 CoroutineDispatcher 객체에 예약한다
- 코루틴 빌더 함수를 호출한 코루틴은 계속해서 실행된다

```jsx
fun main() = runBlocking<Unit> {
  launch {
    println("작업1")
  }
  println("작업2")
}
/*
// 결과:
작업2
작업1
*/
```

메인 스레드에서 실행되는 runBlocking 코루틴에 의해 launch 함수가 호출되면 메인 스레드를 사용하는 CoroutineDispatcher 객체에 launch 코루틴의 실행이 즉시 예약된다.

runBlocking 코루틴이 메인 스레드를 양보하지 않고 계속해서 실행되므로 launch 코루틴은 실행되지 못하며, runBlocking 코루틴에 의해 작업2가 출력되고 나서야 메인 스레드가 자유로워져 launch 코루틴이 실행된다.

→ 스레드를 양보하기 전까지 메인 스레드를 점유하는 코루틴의 특성과 양보받은 스레드를 사용해 실행되는 코루틴의 특징을 잘 나타냄

#### CoroutineStart.ATOMIC

코루틴이 실행 요청됐지만 CoroutineDispatcher 객체가 사용할 수 있는 스레드가 모두 작업 중이어서 스레드로 보내지지 않는 경우, 생성 상태에 머문다.

→ 실행 대기 상태

실행 대기 상태의 코루틴이 취소되면 어떤 일이 일어날까?

```jsx
fun main() = runBlocking<Unit> {
  val job = launch {
    println("작업1")
  }
  job.cancel() // 실행 대기 상태의 코루틴에 취소 요청
  println("작업2")
}
/*
// 결과:
작업2
*/
```

launch 코루틴은 runBlocking 코루틴이 메인 스레드를 양보할 때까지 실행 대기 상태에 머문다.

runBlocking 코루틴을 완료하기 전에 job.cancel()을 호출하면 launch 코루틴이 취소돼 작업이 출력되지 않는다.

launch 함수의 start 인자로 CoroutineStart.ATOMIC 옵션을 적용하면 해당 옵션이 적용된 코루틴은 실행 대기 상태에서 취소되지 않는다.

```jsx
fun main() = runBlocking<Unit> {
  val job = launch(start = CoroutineStart.ATOMIC) {
    println("작업1")
  }
  job.cancel() // 실행 대기 상태의 코루틴에 취소 요청
  println("작업2")
}
/*
// 결과:
작업2
작업1
*/
```

launch 코루틴이 취소되지 않아 작업2와 작업1이 모두 출력된 것을 확인할 수 있다.

⇒ CoroutineStart.ATOMIC 옵션은 코루틴의 **실행 대기 상태에서 취소를 방지하기 위한 옵션**

#### CoroutineStart.UNDISPATCHED

작업 대기열을 거치지 않고 호출자의 스레드에서 즉시 실행된다.

```jsx
fun main() = runBlocking<Unit> {
  launch(start = CoroutineStart.UNDISPATCHED) {
    println("작업1")
  }
  println("작업2")
}
/*
// 결과:
작업1
작업2
*/
```

<img width="508" height="240" alt="스크린샷 2025-08-04 오전 12 31 40" src="https://github.com/user-attachments/assets/b53c6059-a779-455e-86f0-f3fcd7db6b49" />


즉시 호출자의 스레드인 메인 스레드에 할당돼 실행된다.

→ launch 함수를 호출한 즉시 launch 코루틴이 메인 스레드를 점유해 작업1이 먼저 실행되고, 이후 작업2가 실행되는 것을 확인할 수 있다.

주의할 점

- 처음 코루틴 빌더가 호출됐을 때만 coroutineDispatcher 객체를 거치지 않고 실행된다.

```jsx
fun main() = runBlocking<Unit> {
  launch(start = CoroutineStart.UNDISPATCHED) {
    println("일시 중단 전에는 CoroutineDispatcher을 거치지 않고 즉시 실행된다")
    delay(100L)
    println("일시 중단 후에는 CoroutineDispatcher을 거쳐 실행된다")
  }
}
```

## 무제한 디스패처

### 무제한 디스패처란?

코루틴을 자신을 실행시킨 스레드에서 즉시 실행하도록 만드는 디스패처

→ 호출된 스레드가 무엇이든지 상관없기 때문에 실행 스레드가 제한되지 않으므로 무제한 디스패처이다.

```jsx
fun main() = runBlocking<Unit> {
  launch(Dispatchers.Unconfined) { // Dispatchers.Unconfined를 사용해 실행되는 코루틴
    println("launch 코루틴 실행 스레드: ${Thread.currentThread().name}") // launch 코루틴이 실행되는 스레드 출력
  }
}
/*
// 결과:
launch 코루틴 실행 스레드: main @coroutine#2
*/
```

runBlocking 코루틴은 메인 스레드에서 실행된다.

runBlocking 코루틴에서 호출되는 launch 코루틴 빌더 함수는 코루틴을 Dispatchers.Unconfined를 사용해 실행한다.

launch 코루틴 빌더 함수를 호출하는 스레드는 메인 스레드이므로 Dispatchers.Unconfined를 사용해 실행되는 launch 코루틴은 자신을 실행시킨 메인 스레드에서 실행된다.

### 무제한 디스패처의 특징

- 코루틴이 자신을 생성한 스레드에서 즉시 실행된다
- 중단 시점 이후의 재개는 코루틴을 재개하는 스레드에서 한다

#### 코루틴이 자신을 생성한 스레드에서 즉시 실행된다

```jsx
fun main() = runBlocking<Unit>(Dispatchers.IO) {
  println("runBlocking 코루틴 실행 스레드: ${Thread.currentThread().name}") // runBlocking 코루틴이 실행되는 스레드 출력
  launch(Dispatchers.Unconfined) { // Dispatchers.Unconfined를 사용해 실행되는 코루틴
    println("launch 코루틴 실행 스레드: ${Thread.currentThread().name}") // launch 코루틴이 실행되는 스레드 출력
  }
}
/*
// 결과:
runBlocking 코루틴 실행 스레드: DefaultDispatcher-worker-1 @coroutine#1
launch 코루틴 실행 스레드: DefaultDispatcher-worker-1 @coroutine#2
*/
```

runBlocking 코루틴이 실행될 때 Dispatchers.IO를 사용하도록 설정해 runBlocking 코루틴이 실행되는 스레드를 출력한다.

launch 코루틴이 무제한 디스패처를 사용해 실행되도록 해서 launch 코루틴이 실행되는 스레드를 출력한다.

runBlocking 코루틴은 Dispatchers.IO의 공유 스레드풀의 스레드 중 하나를 사용해 실행되고, 그 내부에서 실행되는 launch 코루틴은 runBlocking 코루틴이 사용하던 스레드를 그대로 사용해 실행된다.

```jsx
fun main() = runBlocking<Unit>(Dispatchers.IO) {
  println("runBlocking 코루틴 실행 스레드: ${Thread.currentThread().name}") // runBlocking 코루틴이 실행되는 스레드 출력
  launch { // Dispatchers.Unconfined를 사용해 실행되는 코루틴
    println("launch 코루틴 실행 스레드: ${Thread.currentThread().name}") // launch 코루틴이 실행되는 스레드 출력
  }
}
/*
// 결과:
runBlocking 코루틴 실행 스레드: DefaultDispatcher-worker-1 @coroutine#1
launch 코루틴 실행 스레드: DefaultDispatcher-worker-3 @coroutine#2
*/
```

launch 코루틴은 제한된 디스패처인 Dispatchers.IO를 사용해 실행된다.

runBlocking 코루틴 실행 스레드는 DefaultDispatcher-worker-1 이지만, luanch 코루틴을 실행한 스레드는 DefaultDispatcher-worker-3이다.

→ Dispatchers.IO에 launch 코루틴을 실행 요청하면 CoroutineDispatcher 객체의 작업 대기열에 launch 코루틴이 들어간 후 Dispatchers.IO에 의해 사용할 수 있는 스레드로 보내지는 과정을 거치기 때문

#### 중단 시점 이후의 재개는 코루틴을 재개하는 스레드에서 한다

무제한 디스패처를 사용하는 코루틴이 일시 중단 후 재개된다면 자신을 재개시키는 스레드에서 실행된다.

```jsx
fun main() = runBlocking<Unit> {
  launch(Dispatchers.Unconfined) {
    println("일시 중단 전 실행 스레드: ${Thread.currentThread().name}")
    delay(100L)
    println("일시 중단 후 실행 스레드: ${Thread.currentThread().name}")
  }
}
/*
// 결과:
일시 중단 전 실행 스레드: main
일시 중단 후 실행 스레드: kotlinx.coroutines.DefaultExecutor
*/
```

launch 코루틴은 무제한 디스패처를 사용해 실행된다.

일시 중단 전에는 launch 함수를 호출한 메인 스레드에서 코루틴이 실행되지만, 일시 중단 후 재개될 때는 DefaultExecutor라고 불리는 스레드에서 실행된다.

어떤 스레드가 코루틴을 재개시키는지 예측하기 매우 어렵기 때문에 일반적인 상황에서 무제한 디스패처를 사용하면 비동기 작업이 불안정해진다.

→ 테스트 등 특수한 상황에서만 무제한 디스패처를 사용하자.

## 코루틴의 동작 방식과 Continuation

### Continuation Passing Style

코루틴은 코드를 실행하는 도중 일시 중단하고 다른 작업으로 전환한 후 필요한 시점에 다시 실행을 재개하는 기능을 지원한다.

코루틴이 일시 중단을 하고 재개하기 위해서는 코루틴의 실행 정보가 어딘가에 저장돼 전달해야 한다.

CPS (Continuation Passing Style) 코틀린이 코루틴의 실행 정보를 저장하고 전달하는 프로그래밍 방식

Continuation = 이어서 실행해야 하는 작업

Continuation 객체

코루틴의 일시 중단 시점에 코루틴의 실행 상태를 저장한다.

다음에 실행해야 할 작업에 대한 정보가 포함된다.

Continuation 객체를 사용하면 코루틴 재개 시 코루틴의 상태를 복원하고 이어서 작업을 진행할 수 있다.

→ 지금까지 사용한 코루틴의 API는 모두 고수준 API이기 때문에 코루틴 라이브러리에서 제공하는 고수준 API는 Continuation 객체를 캡슐화해 사용자에게 노출하지 않지만 내부적으로는 코루틴의 일시 중단과 재개가 Continuation 객체를 통해 이뤄진다.

#### 코루틴의 일시 중단과 재개로 알아보는 Continuation

코루틴에서 일시 중단이 일어나면 Continuation 객체에 실행 정보가 저장된다.

일시 중단된 코루틴은 Continuation 객체에 대해 resume 함수가 호출돼야 재개된다.

```jsx
fun main() = runBlocking<Unit> {
  println("runBlocking 코루틴 일시 중단 호출")
  suspendCancellableCoroutine<Unit> { continuation: CancellableContinuation<Unit> ->
    println("일시 중단 시점의 runBlocking 코루틴 실행 정보: ${continuation.context}")
  }
  println("일시 중단된 코루틴이 재개되지 않아 실행되지 않는 코드")
}
/*
// 결과:
runBlocking 코루틴 일시 중단 호출
일시 중단 시점의 runBlocking 코루틴 실행 정보: [CoroutineId(1), "coroutine#1":BlockingCoroutine{Active}@51cdd8a, BlockingEventLoop@d44fc21]

프로세스가 종료되지 않는다.
*/
```

→ 실행이 종료되지 않는다는 문제가 있다.

Continuation 객체에 대해 재개가 호출되지 않아 runBlocking 코루틴이 재개되지 못했기 때문이다.

```jsx
fun main() = runBlocking<Unit> {
  println("runBlocking 코루틴 일시 중단 호출")
  suspendCancellableCoroutine<Unit> { continuation: CancellableContinuation<Unit> ->
    println("일시 중단 시점의 runBlocking 코루틴 실행 정보: ${continuation.context}")
    continuation.resume(Unit) // 코루틴 재개 호출
  }
  println("runBlocking 코루틴 재개 후 실행되는 코드")
}
/*
// 결과:
runBlocking 코루틴 일시 중단 호출
일시 중단 시점의 runBlocking 코루틴 실행 정보: [BlockingCoroutine{Active}@551aa95a, BlockingEventLoop@35d176f7]
runBlocking 코루틴 재개 후 실행되는 코드

Process finished with exit code 0
*/
```

delay 함수를 호출하면 suspendCancellableCoroutine이 호출되며, scheduleResumeAfterDelay 함수를 통해 일정 시간 이후에 Continuation 객체를 재개시키는 방식으로 동작한다.

Continuation 객체는 코루틴의 일시 중단 시점에 코루틴의 실행 정보를 저장하며, 재개 시 Continuation 객체를 사용해 코루틴의 실행을 복구할 수 있다.

#### 다른 작업으로부터 결과 수신해 코루틴 재개하기

코루틴 재개 시 다른 작업으로부터 결과를 수신받아야 하는 경우에는 suspendCancellableCoroutine 함수의 타입 인자에 결과로 반환받는 타입을 입력하면 된다.

```jsx
fun main() = runBlocking<Unit> {
  val result = suspendCancellableCoroutine<String> { continuation: CancellableContinuation<String> -> // runBlocking 코루틴 일시 중단 시작
      thread { // 새로운 스레드 생성
        Thread.sleep(1000L) // 1초간 대기
        continuation.resume("실행 결과") // runBlocking 코루틴 재개
      }
    }
  println(result) // 코루틴 재개 시 반환 받은 결과 출력
}
/*
// 결과:
실행 결과

Process finished with exit code 0
*/
```
