## 공유 상태를 사용하는 코루틴의 문제와 데이터 동기화

### 가변 변수를 사용할 때의 문제점

- 코드의 안정성을 위해서라면 불변 변수를 사용해야 한다.
- 하지만, 스레드 간 데이터 전달 및 공유된 자원 사용하는 경우엔 가변 변수를 사용해 상태 공유 및 업데이트 해야 한다.
    
    → 여러 곳에서 동시에 가변 변수 변경 시 데이터 손실 및 불일치 문제 발생 할 수 있다.
    

```kotlin
var count = 0
fun main() = runBlocking<Unit> {
    withContext(Dispatchers.Default) {
        repeat(10_000) {
            launch {
                count += 1
            }
        }
    }
    println("$count")
}

// 호출 시마다 다른 값 출력
```

1. `메모리 가시성` 문제
    - 메모리 가시성: 스레드가 변수를 읽는 메모리 공간에 관한 문제
        - 스레드가 변수 변경 시 메인 메모리가 아닌 CPU 캐시 사용할 경우 CPU 캐시 값이 메인 메모리에 전파되는 데 약간의 시간 소요되어 CPU 캐시 ↔ 메인 메모리 간 데이터 불일치 문제
2. `경쟁 상태` 문제
    - 2개 스레드가 동시에 읽어온 값에서 + 1 하는 연산을 수행한다면 같은 연산이 두 번 일어난다.
    - 해당 연산은 두 번 일어나지만, 2개의 코루틴을 통해 값을 1만큼만 증가 시키므로 하나의 연산은 손실된다.

→ 해당 문제들은 멀티 스레드 환경에서 공유 상태를 사용할 때 데이터 동기화 발생시키는 주범들

### **JVM의 메모리 공간이 하드웨어 메모리 구조와 연결되는 방식**

<img width="852" height="706" alt="image" src="https://github.com/user-attachments/assets/ae4cf245-de7f-4425-88fe-7870374ec839" />


- 스레드마다 스택 영역이라고 불리는 메모리 공간 가짐 → 원시 타입 데이터 저장 및 힙 영역에 저장된 객체에 대한 참조(주소 값) 저장
- 힙 영역은 JVM 스레드에서 공통으로 사용되는 메모리 공간 → 객체나 배열 같은 크고 복잡한 데이터 저장

<img width="808" height="822" alt="image" src="https://github.com/user-attachments/assets/dc556c57-22f9-4214-9bbe-6ac0dd6be0b8" />


- 각 CPU 는 CPU 캐시 메모리를 둔다.
    - 데이터 조회 시 공통 영역인 메인 메모리까지 가지 않고 CPU 캐시 메모리에서 데이터 조회할 수 있도록 한다. →  메모리 액세스 속도 향상

<img width="1280" height="684" alt="image" src="https://github.com/user-attachments/assets/699b41bf-99fe-4433-92e0-d82baa6da404" />


- 하드웨어 메모리 구조는 JVM 스택 영역과 힙 영역 구분 X
    
    → JVM 스택 영역에 저장된 데이터는 CPU 레지스터, CPU 캐시 메모리, 메인 메모리에 모두 나타난다.
    
    → 힙 또한 마찬가지.
    

**→ 이를 통해 두 가지 문제 발생**

1. **공유 상태에 대한 메모리 가시성 문제**
2. **공유 상태에 대한 경쟁 상태 문제**

### 공유 상태에 대한 메모리 가시성 문제와 해결 방법

**공유 상태에 대한 메모리 가시성 문제**

- `공유 상태에 대한 메모리 가시성`: 하나의 스레드가 다른 스레드가 변경된 상태 확인하지 못해 공유 상태를 조회 및 업데이트 시 발생하는 문제
    1. 메인메모리에 저장된 값 스레드가 읽어온다.
    2. 해당 스레드 실행 중인 CPU 에서 공유 상태 CPU Cache Memory 에 저장한다.
    3. 연산 후 플러시가 일어나지 않으면, CPU 캐시 메모리에만 저장되어 메인 메모리와 다른 값을 가진다
    4. 다른 스레드에서 메인 메모리의 공유 상태 값을 가져와 연산하면 해당 CPU 캐시 메모리에 저장한다.
    5. 이후 각 CPU 캐시 메모리의 값이 메인 메모리로 플러시 일어나면 연산 두 번 일어나지만, 공유 상태의 값은 하나만 변경된다.

**`@Volatile` 사용해 공유 상태에 대한 메모리 가시성 문제 해결하기**

- 공유 상태에 대한 메모리 가시성 문제 해결하기 위해선 `@Volatile` 애노테이션 붙이면 된다.

```kotlin
@Volatile
var count = 0
fun main() = runBlocking<Unit> {
    withContext(Dispatchers.Default) {
        repeat(10_000) {
            launch {
                count += 1
            }
        }
    }
    println("$count")
}
```

- `@Volatile` 애노테이션은 설정된 변수를 읽고 쓸 때 CPU 캐시 메모리 사용하지 않는다.
    - 바로 메인 메모리 사용해 저장 및 조회

→ but, 완벽히 10_000이 나오지 않는다. 이유는 **여러 스레드가 메인 메모리의 count 값에 동시에 접근할 수 있기 때문이다.**

### 공유 상태에 대한 경쟁 상태 문제와 해결 방법

**공유 상태에 대한 경쟁 상태 문제**

- `경쟁 상태` : 여러 스레드가 동시에 하나의 값에 접근하면서 발생하는 문제

```kotlin
@Volatile
var count = 0
fun main() = runBlocking<Unit> {
    withContext(Dispatchers.Default) {
        repeat(10_000) {
            launch {
                count += 1
            }
        }
    }
    println("$count")
}
```

- **해당 코드에서 하나의 변수에 여러 개의 스레드가 접근할 수 없도록 막아야 경쟁 상태 문제를 해결 할 수 있다.**

**Mutex 사용해 동시 접근 제한하기**

- 공유 변수의 변경 가능 지점을 `임계 영역` 으로 만들어 동시 접근 제한하는 것
    
    → `Mutex` 객체를 제공해서 임계 영역을 만들 수 있다.
    
    - Mutex 객체의 **lock 일시 중단 함수 호출 시** 락 획득 → 해당 Mutex 객체에 대해 unlock 호출돼 락 해제될 때까지 다른 코루틴이 임계 영역 진입 불가

```kotlin
var count = 0
val mutex = Mutex()

fun main() = runBlocking<Unit> {
    withContext(Dispatchers.Default) {
        repeat(10_000) {
            launch {
                mutex.lock()
                count += 1
                mutex.unlock()
            }
        }
    }
    println("$count")
}

// 10000
```

- **Mutex 객체 사용해 락 획득 후에는 반드시 해제해야 한다.**
    
    → 해제하지 않으면, 해당 임계 영역에 다른 코루틴이 접근하지 못해 문제 발생할 수 있음
    
- `lock - unlock` 대신 `withLock` 함수 사용하면 안전하다.
    - `withLock` 람다식 실행 전에 lock 호출되고, 람다식 모두 실행되면 자동으로 unlock 호출된다.

```kotlin
var count = 0
val mutex = Mutex()

fun main() = runBlocking<Unit> {
    withContext(Dispatchers.Default) {
        repeat(10_000) {
            launch {
                mutex.withLock {
                    count += 1
                }
            }
        }
    }
    println("$count")
}

// 10000
```

![스크린샷 2025-08-04 오후 11.16.28.png](attachment:7a25e939-1c60-45b6-8cb0-2911c7f08ca2:스크린샷_2025-08-04_오후_11.16.28.png)

- `ReetrantLock` 객체 대신 `Mutex`  사용 하는 이유
    - `Mutex` 는 일시 중단 함수로, 코루틴이 Mutex 객체의 lock 함수 호출했는데 이미 다른 코루틴에 의해 lock 걸려있으면 기존 락 해제될 때까지 스레드 양보하고 일시 중단한다.
    - `ReetrantLock` 은 이미 다른 스레드에서 락 획득했다면, 해당 코루틴은 락이 해제될 때까지 lock 호출한 스레드를 **블로킹하고 기다린다.**
    - **but, ReetrantLock 객체를 사용해서도 안전한 임계 영역을 만들 수 있다!**

**공유 상태 변경을 위해 전용 스레드 사용하기**

- 공유 상태에 접근할 때 `하나의 전용 스레드`만 사용할 수 있도록 강제하면 공유 상태에 동시 접근하는 문제 해결할 수 있다.
    
    → `newSingleThreadContext()` 사용해 공유 상태에 접근하는 스레드를 만들어 사용
    
    ( `Dispathers.IO.limitedParallelism(1)` 로도 사용 가능 )
    

## CoroutineStart의 다양한 옵션들 살펴보기

### CoroutineStart.DEFAULT

- `launch` 의 start 인자로 아무런 값 전달되지 않으면 `CoroutineStart.DEFAULT` 로 설정
- 해당 인자는 코루틴 빌더 함수 호출한 즉시 생성된 코루틴의 실행을 `CoroutineDispatcher` 객체에 예약하며, 코루틴 빌더 함수 호출한 코루틴은 계속해서 실행된다.

```kotlin
fun main() = runBlocking<Unit> {
    launch {
        println("작업 1")
    }
    println("작업 2")
}

// 작업 2
// 작업 1
```

### CoroutineStart.ATOMIC

- 코루틴 실행 요청됐지만, CoroutineDispatcher 객체가 사용할 수 있는 스레드가 모두 작업 중이라 스레드로 보내지지 않는 경우 → `실행 대기 상태`
- 만약, 실행 대기 상태 코루틴 취소 시 어떻게 될까?
    - 일반적인 코루틴은 실행되기 전에 취소되면 실행되지 않고 종료된다.
- 이 때, start 의 인자로 `CoroutineStart.ATOMIC` 적용 시 실행 대기 상태에서 취소되지 않는다.

→ 해당 옵션은 코루틴의 실행 대기 상태에서 취소 방지하기 위한 옵션

### CoroutineStart.UNDISPATCHED

- **해당 옵션은 CoroutineDispatcher 의 작업 대기열에 들어가지 않고, 호출자의 스레드에서 즉시 실행된다.**

```kotlin
fun main() = runBlocking<Unit> {
    launch(start = CoroutineStart.UNDISPATCHED) {
        println("작업 1")
    }
    println("작업 2")
}

// 작업 1
// 작업 2
```

- 처음 코루틴 빌더가 호출됐을 때만 CoroutineDispatcher 객체 거치지 않고 실행된다.

```kotlin
fun main() = runBlocking<Unit> {
    launch(start = CoroutineStart.UNDISPATCHED) {
        println("작업 1")
        delay(100L)
        println("작업 2")
    }
    println("작업 3")
}
/* 

작업 1
작업 3
작업 2

*/
```

- 일시 중단 후에는 CoroutineDispatcher 를 거쳐서 실행된다.

## 무제한 디스패처

### 무제한 디스패처란?

- `무제한 디스패처(Unconfined Dispatcher)` : 코루틴을 자신을 실행시킨 스레드에서 즉시 실행하도록 만드는 디스패처
    - (호출된 스레드가 무엇이든지 상관없기 때문에 실행 스레드가 제한되지 않으므로 무제한 디스패처라는 이름이 붙었다.)

```kotlin
fun main() = runBlocking<Unit> {
    launch(Dispatchers.Unconfined) {
        println("launch 코루틴 실행 스레드 : ${Thread.currentThread().name}")
    }
}

/* 
launch 코루틴 실행 스레드 : main @coroutine#2
*/
```

- runBlocking 이 메인 스레드에서 돌아가고 있으며, launch 빌더가 Unconfined 디스패처이므로 main 스레드에서 코루틴 실행된다.

### 무제한 디스패처의 특징

1. **코루틴이 자신을 생성한 스레드에서 즉시 실행된다**

```kotlin
fun main() = runBlocking<Unit>(Dispatchers.IO) {
    println("runBlocking 코루틴 실행 스레드 : ${Thread.currentThread().name}")
    launch(Dispatchers.Unconfined) {
        println("launch 코루틴 실행 스레드 : ${Thread.currentThread().name}")
    }
}

/*
runBlocking 코루틴 실행 스레드 : DefaultDispatcher-worker-1 @coroutine#1
launch 코루틴 실행 스레드 : DefaultDispatcher-worker-1 @coroutine#2
*/
```

- runBlocking 이 IO 디스패처에서 실행되기에 공유 스레드풀의 스레드 중 하나에서 실행되고, launch 코루틴 또한 해당 스레드에서 실행된다.
- `CoroutineStart.UNDISPATCHED` 옵션 적용 시와 유사하다.
    - 코루틴 일시 중단 후 재개 됐을 때 동작에 차이가 있다.
1. 중단 시점 이후의 재개는 코루틴을 재개하는 스레드에서 한다
- 무제한 디스패처를 사용해 실행되는 코루틴은 자신을 실행시킨 스레드에서 `스레드 스위칭 없이 즉시 실행`되지만, **일시 중단 전까지만 자신을 실행시킨 스레드에서 실행된다.**

```kotlin
fun main() = runBlocking<Unit> {
    launch(Dispatchers.Unconfined) {
        println("일시 중단 전 코루틴 실행 스레드 : ${Thread.currentThread().name}")
        delay(100L)
        println("일시 중단 후 코루틴 실행 스레드 : ${Thread.currentThread().name}")
    }
}

/*

일시 중단 전 코루틴 실행 스레드 : main @coroutine#2
일시 중단 후 코루틴 실행 스레드 : kotlinx.coroutines.DefaultExecutor @coroutine#2

*/
```

- 일시 중단 후 `DefaultExecutor` 스레드에서 실행된다.
    - 해당 스레드는 delay 함수를 실행하는 스레드로 delay 함수가 일시 중단 종료 후 코루틴 재개할 때 사용하는 스레드이다.

→ **어떤 스레드가 코루틴을 재개시키는 지 예측하기 매우 어렵기 때문에** 일반적인 상황에서 무제한 디스패처를 사용하면 비동기 작업이 불안정해진다. 테스트 등 특수한 상황에서만 사용하자

## 코루틴의 동작 방식과 Continuation

### Continuation Passing Style

- 코루틴은 코드 실행하는 도중 일시 중단하고 다른 작업으로 전환 후 필요한 시점에 다시 실행 재개하는 기능 지원한다.
    
    → 즉, 코루틴이 일시 중단하고 재개하기 위해서는 **어딘가에 저장되어야 한다.**
    
- 코루틴의 실행 정보 저장하고 전달하는 `CPS` 란 프로그래밍 방식을 채택하고 있다.
- 코루틴에서 이어서 실행해야 하는 작업 전달 위해 `Continuation` 객체 제공한다.
    - 코루틴의 일시 중단 시점에 **`코루틴 실행 상태 저장`**

### 코루틴의 일시 중단과 재개로 알아보는 Continuation

- 코루틴 일시 중단 시 Continuation 객체에 실행 정보 저장 → Continuation 객체에 대해 resume 함수가 호출돼야 재개된다.

```kotlin
fun main() = runBlocking<Unit> {
    println("runBlocking 코루틴 일시 중단 호출")
    suspendCancellableCoroutine<Unit> { continuation ->
        println("일시 중단 시점의 runBlocking 코루틴 실행 정보: ${continuation.context}")
    }
    println("일시 중단된 코루틴이 재개되지 않아 실행되지 않는 코드")
}

/*
runBlocking 코루틴 일시 중단 호출
일시 중단 시점의 runBlocking 코루틴 실행 정보: [CoroutineId(1), "coroutine#1":BlockingCoroutine{Active}@7006c658, BlockingEventLoop@34033bd0]

*/
```

→ 프로세스가 종료되지 않는다. + 실행되지 않는 코드가 보이지 않는다.

```kotlin
fun main() = runBlocking {
    println("runBlocking 코루틴 일시 중단 호출")
    suspendCancellableCoroutine<Unit> { continuation: CancellableContinuation<Unit> ->
        println("일시 중단 시점의 runBlocking 코루틴 실행 정보: ${continuation.context}")
        continuation.resume(Unit)
    }
    println("runBlocking 코루틴 재개 후 실행되는 코드")
}

/*

runBlocking 코루틴 일시 중단 호출
일시 중단 시점의 runBlocking 코루틴 실행 정보: [CoroutineId(1), "coroutine#1":BlockingCoroutine{Active}@7006c658, BlockingEventLoop@34033bd0]
runBlocking 코루틴 재개 후 실행되는 코드

*/

```

### 다른 작업으로부터 결과 수신해 코루틴 재개하기

- 코루틴 재개 시 다른 작업으로부터 결과 수신받아야 하는 경우엔 `suspendCancellableCoroutine` 함수의 타입 인자에 결과로 반환받는 타입 설정

```kotlin
fun main() = runBlocking<Unit> {
   val result = suspendCancellableCoroutine<String> { continuation ->
       thread {
           Thread.sleep(1000L)
           continuation.resume("실행 결과")
       }
   }

    println(result)
}

// 실행 결과
```
