# 11장 - 코루틴 심화

## 11.1. 공유 상태를 사용하는 코루틴의 문제와 데이터 동기화

### 11.1.1. 가변 변수를 사용할 때의 문제점

- 코드의 안정성을 높이기 위해서는 가변 변수 대신 불변 변수를 사용해야 한다. 하지만, 스레드 간에 데이터를 전달하거나 공유된 자원을 사용하는 경우에는 가변 변수를 사용해 상태를 공유하고 업데이트해야 한다. 이런 경우 여러 스레드에서 가변 변수에 동시에 접근해 값을 변경하면 데이터의 손실이나 불일치로 인해 심각한 버그가 발생할 수 있다.
    
    ```kotlin
    fun main() = runBlocking<Unit> {
      withContext(Dispatchers.Default) {
        repeat(10_000) {
          launch {
            count += 1
          }
        }
      }
      println("count = ${count}")
    }
    ```
    
    > // 결과1:
    count = 9062  // 매번 다른 값이 나온다.<br>
    // 결과2:
    count = 9019  // 매번 다른 값이 나온다.<br>
    // 결과3:
    count = 8644  // 매번 다른 값이 나온다.
    
- Dispatchers.Default 객체는 멀티 스레드를 사용하기 때문에 1만 개의 코루틴이 count에 접근하고 값을 변경하는 작업은 병렬로 실행된다.
- 결과를 보면 10000이 출력되지도 않고, 실행할때마다 다른 값이 나온다. 원인은 크게 2가지로 요약될 수 있다.
    1. 메모리 가시성 문제
        1. 스레드가 변수를 읽는 메모리 공간에 관한 문제로 CPU 캐시와 메인 메모리 등으로 이뤄지는 하드웨어의 메모리 구조와 연관되어 있다. 스레드가 변수를 변경시킬 때 메인 메모리가 아닌 CPU 캐시를 사용할 경우 CPU 캐시 값이 메인 메모리에 전파되는 데 약간의 시간이 걸려 CPU 캐시와 메인 메모리 간에 데이터 불일치 문제가 생긴다. 따라서, 다른 스레드에서 해당 변수를 읽을 때 변수가 변경된 것을 확인하지 못할 수 있다.
    2. 경쟁 상태(race condition) 문제이다. 2개의 스레드가 동시에 값을 읽고 업데이트 시키면 같은 연산이 두 번 일어난다. 예를 들어, count 변수에 저장된 값이 1000일 때 2개의 스레드가 동시에 count 변수를 읽고 업데이트한다면 count 변수가 1000에서 1001이 되는 연산이 두 번 일어난다. 즉, 2개의 코루틴이 값을 1만큼만 증가시키므로 하나의 연산은 손실된다.

### 11.1.2. JVM의 메모리 공간이 하드웨어 메모리 구조와 연결되는 방식

- JVM은 스레드마다 스택 영역이라고 불리는 메모리 공간을 갖고 있고, 이 스택 영역에는 원시 타입의 데이터가 저장되거나 힙 영역에 저장된 객체에 대한 참조(주소 값)이 저장된다. 힙 영역은 JVM 스레드에서 공통으로 사용되는 메모리 공간으로 객체나 배열 같은 크고 복잡한 데이터가 저장된다.

<img width="660" alt="image" src="https://github.com/user-attachments/assets/b6de11c6-6bdc-4ecc-acbd-ce63719f5bc4" />

    
- 컴퓨터(하드웨어)의 메모리 구조는 아래와 같이 CPU 레지스터, CPU 캐시 메모리, 메인 메모리 영역으로 구성된다. 각 CPU는 CPU 캐시 메모리를 두며, 데이터 조회 시 공통 영역인 메인 메모리까지 가지 않고 CPU 캐시 메모리에서 데이터를 조회할 수 있도록 만들어 메모리 액세스 속도를 향상시킨다.
    
<img width="660" alt="image" src="https://github.com/user-attachments/assets/631c5203-1553-4dce-8352-4547de5566b9" />

    
- JVM의 메모리 공간인 스택 영역과 힙 영역을 하드웨어 메모리의 구조와 연결해 보자.
    
 <img width="660" alt="image" src="https://github.com/user-attachments/assets/d0ceb8ac-172d-4fca-9e60-b911c45d1c75" />

- 하드웨어 메모리 구조는 JVM 스택 영역과 힙 영역을 구분하지 않는다. 따라서, JVM의 스택 영역에 저장된 데이터들은 CPU 레지스터, CPU 캐시 메모리, 메인 메모리 모두에 나타날 수 있으며, 힙 영역도 마찬가지다. 이런 구조로 인해 멀티 스레드 환경에서 공유 상태를 사용할 때 두 가지 문제가 발생한다.
    - 공유 상태에 대한 메모리 가시성 문제
    - 공유 상태에 대한 경쟁 상태 문제

### 11.1.3. 공유 상태에 대한 메모리 가시성 문제와 해결 방법

11.1.3.1. 공유 상태에 대한 메모리 가시성 문제

- 하나의 스레드가 다른 스레드가 변경된 상태를 확인하지 못하는 것으로 서로 다른 CPU에서 실행되는 스레드들에서 공유 상태를 조회하고 업데이트할 때 생기는 문제이다.
- 공유 상태는 처음에 메인 메모리에 저장되어 있다. 하나의 스레드가 공유 상태를 읽어오면 해당 스레드를 실행 중인 CPU는 공유 상태를 CPU 캐시 메모리에 저장한다. 스레드가 count 값을 증가시키는 연산을 실행하려고 메인 메모리에서 count 값을 읽어오면 CPU 캐시 메모리에는 count = 1000이라는 정보가 저장되며, 스레드는 이 값을 사용해 count값을 증가시키는 연산을 실행한다.

<img width="660" alt="image" src="https://github.com/user-attachments/assets/dc17d3af-34a5-41ee-9af1-f1eecbee90c1" />


<img width="660" alt="image" src="https://github.com/user-attachments/assets/6800b010-e05c-4903-9a37-b291f822cdce" />


- 연산이 완료되면 count = 1001 되지만 스레드는 이 정보를 메인 메모리에 쓰지 않고 CPU 캐시 메모리에 쓴다. CPU 캐시 메모리에 변경된 count 값은 플러시가 일어나지 않으면 메인 메모리로 전파되지 않는다.
    
 <img width="660" alt="image" src="https://github.com/user-attachments/assets/9a314e6b-5d15-405c-b4bf-84c5c683c3db" />

    
- CPU 캐시 메모리의 데이터가 메인 메모리에 전파되지 않은 상태에서 다른 CPU의 스레드에서 count 변수 값을 읽는 상황이 있다면, 해당 스레드는 count의 값을 1000으로 인식하게 되며, 이에 대해 count += 1 연산을 수행해 count = 1001을 자신의 CPU 캐시 메모리에 쓰게 된다.
    
<img width="660" alt="image" src="https://github.com/user-attachments/assets/174fd4bf-7390-47c4-ae15-ac45acf02062" />

    
- 이후, 각 CPU 캐시 메모리의 값이 메인 메모리로 플러시가 일어나면 연산은 두 번 일어나지만 count 변수 값은 하나만 증가하게 된다.
    
 <img width="660" alt="image" src="https://github.com/user-attachments/assets/41dfe6c8-42e2-4227-9d36-59144d473141" />

    
- 이렇게 하나의 스레드에서 변경한 변수의 상태 값을 다른 스레드가 알지 못해 생기는 메모리 동기화 문제를 메모리 가시성 문제라고 한다.

11.1.3.2. @Volatile 사용해 공유 상태에 대한 메모리 가시성 문제 해결하기

- 코틀린에서 메모리 가시성 문제를 해결하기 위해서는 Volatile 어노테이션을 사용하면 된다.
    
    ```kotlin
    @Volatile
    var count = 0
    
    fun main() = runBlocking<Unit> {
      withContext(Dispatchers.Default) {
        repeat(10_000) {
          launch {
            count += 1
          }
        }
      }
      println("count = ${count}")
    }
    ```
    
- volatile 어노테이션이 설정된 변수를 읽고 쓸 때는 CPU 캐시 메모리를 사용하지 않는다. 즉, 각 스레드는 count 변수의 값을 변경시키는 데 CPU 캐시 메모리를 사용하지 않고 메인 메모리를 사용한다.
- 따라서, 스레드에서는 count 변수의 값을 1 증가시키는 연산을 위해 메인 메모리에서 곧바로 count 값을 조회해 오며, 값에 대한 변경 연산도 메인 메모리에서 직접 수행한다.
    
  <img width="660" alt="image" src="https://github.com/user-attachments/assets/1007cb6a-38ea-4fd0-b91d-737efd7aac47" />

    
    > count = 9122
    > 
    - 가시성 문제를 해결했지만 여전히 count 변수의 값이 10000이 나오지 않는다. 메인 메모리에서만 count 변수의 데이터를 변경하더라도 여전히 여러 스레드가 메인 메모리의 count 변수에 동시에 접근할 수 있기 때문이다.

### 11.1.4. 공유 상태에 대한 경쟁 상태 문제와 해결 방법

11.1.4.1. 공유 상태에 대한 경쟁 상태 문제

- 변수가 volatile로 선언돼 메인 메모리에만 저장되어도 문제가 해결되지 않는 이유는 여전히 여러 스레드가 동시에 메인 메모리에 접근할 수 있기 때문이다. 여러 스레드가 동시에 하나의 값에 접근하면서 발생하는 문제를 경쟁 상태(race condition) 문제라고 한다.
    
   <img width="660" alt="image" src="https://github.com/user-attachments/assets/0a6bad4c-ec5f-4921-93f2-c44d2d717960" />

    
- 스레드에서 동시에 메인 메모리의 값 count = 1000에 접근해 count += 1 연산을 하면 실제로는 두번 연산이 일어나지만 count 변수의 값은 하나만 증가한다. 즉, 연산이 중복돼 실행된다.
    
  <img width="660" alt="image" src="https://github.com/user-attachments/assets/14f99ae9-0677-4e16-9d30-b41a31122b60" />

    
11.1.4.2. Mutex 사용해 동시 접근 제한하기

- 동시 접근을 제한하는 간단한 방법은 공유 변수의 변경 가능 지점을 임계 영역으로 만들어 동시 접근을 제한하는 것이다. 코틀린에서는 코루틴에 대한 임계 영역을 만들기 위한 Mutex 객체를 제공한다.
    - 임계 영역(Critical Section): 여러 스레드(또는 코루틴)가 **공유 자원**(예: 변수, 리스트 등)을 접근할 때, **오직 한 번에 하나의 실행 흐름만 접근할 수 있도록 제한하는 코드 블록**을 의미.
- Mutex 객체에 대해 lock 일시 중단 함수가 호출되면 락이 획득되며, 이후 해당 Mutex 객체에 대해 unlock이 호출돼 락이 해제될 때까지 다른 코루틴이 해당 임계 영역에 진입할 수 없다.
    
    ```kotlin
    var count = 0
    val mutex = Mutex()
    
    fun main() = runBlocking<Unit> {
      withContext(Dispatchers.Default) {
        repeat(10_000) {
          launch {
            mutex.lock() // 임계 영역 시작 지점
            count += 1
            mutex.unlock() // 임계 영역 종료 지점
          }
        }
      }
      println("count = ${count}")
    }
    ```
    
    > count = 10000
    > 
    - Mutex 객체에 대해 lock, unlock을 사용해 count += 1을 실행하는 부분을 임계 영역으로 만들어 해당 영역에 둘 이상의 코루틴이 접근할 수 없다.
- Mutex 객체를 사용해 락을 획득한 후에는 꼭 해제해야 한다. 만약 해제하지 않으면 해당 임계 영역은 다른 스레드에서 접근이 불가능하게 돼 문제를 일으킬 수 있다. 코드가 복잡해질수록 lock-unlock 쌍을 사용하면 개발자의 실수로 문제를 일으킬 가능성이 커진다.
- 이런 문제때문에 Mutex 객체를 사용해 임계 영역을 만들 때는 withLock 일시 중단 함수를 사용하는 것이 안전하다. withLock을 사용하면 withLock의 람다식 실행 이전에 lock이 호출되고, 람다식이 모두 실행되면 unlock이 호출돼 안전하게 Mutex 객체를 사용할 수 있다.
    
    ```kotlin
    var count = 0
    val mutex = Mutex()
    
    fun main() = runBlocking<Unit> {
      withContext(Dispatchers.Default) {
        repeat(10_000) {
          launch {
            mutex.withLock {
              count += 1
            }
          }
        }
       }
      println("count = ${count}")
    }
    ```
    
    ```kotlin
    public suspend inline fun <T> Mutex.withLock(owner: Any? = null, action: () -> T): T {
        contract {
            callsInPlace(action, InvocationKind.EXACTLY_ONCE)
        }
    
        lock(owner)
        try {
            return action()
        } finally {
            unlock(owner)
        }
    }
    ```
    

- 왜 코루틴에 사용할 때는 같은 Mutex 기능을 하는 ReentrantLock 객체 대신 Mutex 객체를 사용하는 것일까? Mutex 객체의 lock이 일시 중단 함수란 점에 주목하자. 코루틴이 Mutex 객체의 lock 함수를 호출했는데 이미 다른 코루틴에 의해 Mutex 객체에 락이 걸려있으면 코루틴은 기존의 락이 해제될 때까지 스레드를 양보하고 일시 중단한다. 그리고 이를 통해 코루틴이 일시 중단되는 동안 스레드가 블로킹되지 않도록 해서 스레드에서 다른 작업이 실행될 수 있도록 한다. 이후 기존의 락이 해제되면 코루틴이 재개돼 Mutex 객체의 락을 획득한다.
- 반면에 코루틴에서 ReentrantLock 객체에 대해 lock을 호출했을 때 이미 다른 스레드에서 락을 획득했다면 코루틴은 락이 해제될 때까지 lock을 호출한 스레드를 블로킹하고 기다린다. 즉, 락이 해제될 때까지 lock을 호출한 스레드를 다른 코루틴이 사용할 수 없다. 이런 특성 때문에 코루틴에서는 Mutex 객체를 사용하는 것이 권장된다.
    
    ```kotlin
    fun main() = runBlocking<Unit> {
    	  withContext(Dispatchers.Default) {
    		    repeat(10_000) {
    			      launch {
    				        reentrantLock.lock() // 스레드를 블록하고 기존의 락이 해제될 때까지 기다림
    				        count += 1
    				        reentrantLock.unlock()
    			      }
    		    }
    	  }
    	  println("count = ${count}")
    }
    ```
    

11.1.4.3. 공유 상태 변경을 위해 전용 스레드 사용하기

- 스레드 간에 공유 상태를 사용해 생기는 문제점은 다수의 스레드가 공유 상태에 동시에 접근할 수 있기 때문에 일어난다. 따라서, 공유 상태에 접근할 때 하나의 전용 스레드만 사용하도록 강제하면 문제를 해결할 수 있다.
- 하나의 전용 스레드만 사용할 수 있도록 만드는 방법은 간단하다. newSingleThreadContext 함수를 사용해 단일 스레드로 구성된 CoroutineDispatcher 객체를 생성해 특정 연산을 위해 사용되도록 만들면 된다.
    
    ```kotlin
    var count = 0
    val countChangeDispatcher = newSingleThreadContext("CountChangeThread")
    
    fun main() = runBlocking<Unit> {
    	  withContext(Dispatchers.Default) {
    		    repeat(10_000) {
    			      launch { // count 값을 변경 시킬 때만 사용
    				        increaseCount()
    			      }
    		    }
    	  }
    	  println("count = ${count}")
    }
    
    suspend fun increaseCount() = coroutineScope {
    	  withContext(countChangeDispatcher) {
    		    count += 1
    	  }
    }
    ```
    
- launch 코루틴이 Dispatchers.Default를 통해 백그라운드 스레드에서 실행되더라도 increaseCount 함수가 호출되면 launch 코루틴의 실행 스레드가 CountChangeThread로 전환돼 count 변수에 대한 동시 접근이 일어나지 않는다.

### 추가 자료. 원자성 있는 데이터 구조를 사용한 경쟁 상태 문제 해결

- 원자성 있는 객체 사용해 경쟁 상태 문제 해결하기
    
    ```kotlin
    var count = AtomicInteger(0)
    
    fun main() = runBlocking<Unit> {
      withContext(Dispatchers.Default) {
        repeat(10_000) {
          launch {
            count.getAndUpdate {
              it + 1 // count값 1 더하기
            }
          }
        }
      }
      println("count = ${count}")
    }
    ```
    
    - AtomicInteger 객체와 같이 원자성 있는 객체는 여러 스레드가 동시에 접근해도 한 번에 하나의 스레드만 접근할 수 있도록 제한한다. 따라서, 복수의 코루틴이 병렬로 실행되더라도 특정 시점에 count에 대한 getAndUpdate 연산을 실행하는 코루틴은 하나뿐이다.
- 객체의 참조에 원자성 부여하기
    
    ```kotlin
    data class Counter(val name: String, val count: Int)
    val atomicCounter = AtomicReference(Counter("MyCounter", 0)) // 원자성 있는 Counter 만들기
    
    fun main() = runBlocking<Unit> {
      withContext(Dispatchers.Default) {
        repeat(10_000) {
          launch {
            atomicCounter.getAndUpdate {
              it.copy(count = it.count + 1) // MyCounter의 count값 1 더하기
            }
          }
        }
      }
      println(atomicCounter.get())
    }
    ```
    
    - AtomicReference 클래스를 사용하면 복잡한 객체의 참조에 대해 원자성을 부여할 수 있다. 데이터 클래스로 Counter를 선언하고, AtomicReferencefh Counter 객체를 감싸 원자성을 부여한다.
- 원자성 있는 객체를 코루틴에서 사용할 때의 한계
    
    ```kotlin
    var count = AtomicInteger(0)
    
    fun main() = runBlocking<Unit> {
      withContext(Dispatchers.Default) {
        repeat(10_000) {
          launch {
            count.getAndUpdate { // 만약 다른 스레드가 연산을 실행중이면, 코루틴은 스레드를 블로킹 시키고 대기한다.
              it + 1
            }
          }
        }
      }
      println("count = ${count}")
    }
    ```
    
    - 코루틴이 원자성 있는 객체에 접근할 때 이미 다른 스레드의 코루틴이 해당 객체에 대한 연산을 실행 중인 경우, 코루틴은 스레드를 블로킹하고 연산 중인 스레드가 연산을 모두 수행할 때까지 기다린다. 이는 코루틴에서 ReentrantLock 객체에 대해 lock을 사용하는 것과 비슷하다. 따라서, 원자성 있는 객체를 코루틴에서 사용할 때는 원자성 있는 객체가 스레드를 블로킹시킬 수 있다는 점을 고려해야 한다.
- 원자성 있는 객체를 사용할 때 많이 하는 실수
    
    ```kotlin
    var count = AtomicInteger(0)
    
    fun main() = runBlocking<Unit> {
      withContext(Dispatchers.Default) {
        repeat(10_000) {
          launch {
            val currentCount = count.get()
            // 위 코드와 아래 코드의 실행 사이에 다른 스레드가 count의 값을 읽거나 변경할 수 있다.
            count.set(currentCount + 1)
          }
        }
      }
      println("count = ${count}")
    }
    ```
    
    > count = 8492
    > 
    - 원자성 있는 객체를 사용할 때 많이 하는 실수 중 하나는 원자성 있는 객체의 읽기와 쓰기를 따로 실행하는 것이다.
    - 위 코드에서는 count에 대한 get 함수를 실행해 count 값을 가져온 후 set 함수를 실행해 1을 더한다. 이때 get 함수가 실행되고 나서 set함수 실행 전에 다른 스레드에서 count에 대한 읽기 연산 또는 쓰기 연산을 실행할 수 있으므로 경쟁 상태 문제가 생긴다.
    - 이를 해결하기 위해서는 앞서 다룬 getAndUpdate와 같은 읽기와 쓰기를 함께 실행하는 함수를 사용해야 한다. 대표적으로 AtomicInteger 객체의 값을 읽고 1을 더하는 작업을 실행하는 incrementAndGet이 있다.
        
        ```kotlin
        var count = AtomicInteger(0)
        
        fun main() = runBlocking<Unit> {
          withContext(Dispatchers.Default) {
            repeat(10_000) {
              launch {
                count.incrementAndGet() // count값 1 더하기
              }
            }
          }
          println("count = ${count}")
        }
        ```
        
    - incrementAndGet은 count 값을 읽고 쓸 동안 다른 스레드의 접근을 허용하지 않는다.
    - 이처럼 원자성 있는 객체를 안전하게 사용하기 위해서는 하나의 스레드가 값을 읽고 쓸 동안 다른 스레드의 접근을 허용해서는 안된다.

## 11.2. CoroutineStart의 다양한 옵션들 살펴보기

### 11.2.1. CoroutineStart.DEFAULT

- launch의 start 인자로 아무런 값이 전달되지 않으면 기본 실행 옵션인 CoroutineStart.DEFAULT가 설정된다. 즉, 우리가 지금까지 다뤘던 많은 코루틴들은 CoroutineStart.DEFAULT로 실행됐다.
- 코루틴 빌더의 start 인자로 CoroutineStart.DEFAULT를 사용하면 코루틴 빌더 함수를 호출한 즉시 생성된 코루틴의 실행을 CoroutineDispatcher 객체에 예약하며, 코루틴 빌더 함수를 호출한 코루틴은 계속해서 실행된다.
    
    ```kotlin
    fun main() = runBlocking<Unit> {
      launch {
        println("작업1")
      }
      println("작업2")
    }
    ```
    
    > 작업2<br>
    작업1
  
- runBlocking 코루틴에 의해 launch 함수가 호출되면 메인 스레드를 사용하는 CoroutineDispatcher 객체에 launch 코루틴의 실행이 즉시 예약된다. 하지만, runBlocking 코루틴이 메인 스레드를 양보하지 않고 계속 실행되므로 launch 코루틴은 실행되지 못하며, ‘작업2’가 출력되고 나서야 launch 코루틴이 실행돼 ‘작업1’이 출력된다.

### 11.2.2. CoroutineStart.ATOMIC

- 코루틴이 실행 요청됐지만 CoroutineDispatcher 객체가 사용할 수 있는 스레드가 모두 작업 중이어서 스레드로 보내지지 않는 경우 생성 상태에 머무는데 이를 ‘실행 대기’ 상태라고도 한다.
    
  <img width="660" alt="image" src="https://github.com/user-attachments/assets/f38fd5c5-0c37-4431-b2de-98697ef6c215" />

    
- 실행 대기 상태의 코루틴이 취소되면 어떤 일이 일어날까? 일반적인 코루틴은 실행되기 전에 취소되면 실행되지 않고 종료된다.
    
    ```kotlin
    fun main() = runBlocking<Unit> {
      val job = launch {
        println("작업1")
      }
      job.cancel() // 실행 대기 상태의 코루틴에 취소 요청
      println("작업2")
    }
    ```
    
    > 작업2
  
- launch 코루틴은 runBlocking 코루틴이 메인 스레드를 양보할 때까지 실행 대기 상태에 머문다. 따라서, runBlocking 코루틴을 완료하기 전에 job.cancel()을 호출하면 launch 코루틴이 취소돼 ‘작업2’만 출력된다.
- 하지만, launch 코루틴의 start 인자로 CoroutineStart.ATOMIC 옵션을 적용하면 해당 옵션이 적용된 코루틴은 실행 대기 상태에서 취소되지 않는다.
    
    ```kotlin
    @InternalCoroutinesApi
    public operator fun <T> invoke(block: suspend () -> T, completion: Continuation<T>): Unit =
        when (this) {
            DEFAULT -> block.startCoroutineCancellable(completion)
            ATOMIC -> block.startCoroutine(completion)
            UNDISPATCHED -> block.startCoroutineUndispatched(completion)
            LAZY -> Unit // will start lazily
        }
    ```
    
    - `startCoroutine`은 **취소 가능하지 않은(Non-Cancellable)** 방식으로 코루틴을 시작
    - `suspendCancellableCoroutine` 은 **코루틴이 시작되기 전에 취소 요청이 오면 중단**
    
    ```kotlin
    fun main(): Unit =
      runBlocking {
        val job =
          launch(start = CoroutineStart.ATOMIC) {
            println("작업1")
          }
        job.cancel() // 실행 대기 상태의 코루틴에 취소 요청
        println("작업2")
      }
    ```
    
    > 작업2<br>
    작업1

### 11.2.3. CoroutineStart.UNDISPATCHED

- CoroutineStart.UNDISPATCHED 옵션이 적용된 코루틴은 CoroutineDispatcher 객체의 작업 대기열을 거치지 않고 호출자의 스레드에서 즉시 실행된다.
- 앞서 본 코드는 runBlocking이 먼저 실행되어 ‘작업2’가 출력되고 launch가 실행되어 ‘작업1’이 실행되었다.
    
   <img width="660" alt="image" src="https://github.com/user-attachments/assets/332e1d52-c3f9-47ff-b51f-89d0b12b12e9" />

    
- 하지만, launch에 CoroutineStart.UNDISPATCHED을 적용하면 launch 코루틴은 즉시 호출자의 스레드인 메인 스레드에 할당돼 실행된다. 따라서, ‘작업1’이 먼저 출력된다.
    
    ```kotlin
    fun main() = runBlocking<Unit> {
      launch(start = CoroutineStart.UNDISPATCHED) {
        println("작업1")
      }
      println("작업2")
    }
    ```
    
    > 작업1<br>
    작업2
    
   <img width="660" alt="image" src="https://github.com/user-attachments/assets/da2c933b-4d57-42ad-b316-3010182da3cc" />

    

- 주의할 점은 처음 코루틴 빌더가 호출됐을 때만 CoroutineDisptacher 객체를 거치지 않고 실행된다는 것이다. 만약, 코루틴 내부에서 일시 중단 후 재개되면 CoroutineDispatcher 객체를 거쳐 실행된다.
    
    ```kotlin
    fun main() = runBlocking<Unit> {
      launch(start = CoroutineStart.UNDISPATCHED) {
        println("일시 중단 전에는 CoroutineDispatcher을 거치지 않고 즉시 실행된다")
        delay(100L)
        println("일시 중단 후에는 CoroutineDispatcher을 거쳐 실행된다")
      }
    }
    ```
    
  <img width="660" alt="image" src="https://github.com/user-attachments/assets/f431d31a-3543-4633-8e3d-85355e82bd6c" />

    
## 11.3. 무제한 디스패처 (Unconfined Dispatcher)

### 11.3.1. 무제한 디스패처란?

- 코루틴을 자신을 실행시킨 스레드에서 즉시 실행하도록 만드는 디스패처이다. 이때 호출된 스레드가 무엇이든지 상관없기 때문에 실행 스레드가 제한되지 않으므로 무제한 디스패처라는 이름이 붙었다.
    
    ```kotlin
    fun main() = runBlocking<Unit> {
      launch(Dispatchers.Unconfined) { // Dispatchers.Unconfined를 사용해 실행되는 코루틴
        println("launch 코루틴 실행 스레드: ${Thread.currentThread().name}") // launch 코루틴이 실행되는 스레드 출력
      }
    }
    ```
    
    > launch 코루틴 실행 스레드: main @coroutine#2
    
- runBlocking은 메인 스레드에서 실행되며, runBlocking안에서 호출되는 launch 함수는 코루틴을 Dispatchers.Unconfined를 사용해 실행한다. 이때 launch 함수를 호출하는 스레드는 메인 스레드이므로 Dispatchers.Unconfined를 사용해 실행되는 launch 코루틴은 자신을 실행시킨 메인 스레드에서 실행된다.

### 11.3.2. 무제한 디스패처의 특징

11.3.2.1. 코루틴이 자신을 생성한 스레드에서 즉시 실행된다

```kotlin
fun main() = runBlocking<Unit>(Dispatchers.IO) {
  println("runBlocking 코루틴 실행 스레드: ${Thread.currentThread().name}") // runBlocking 코루틴이 실행되는 스레드 출력
  launch(Dispatchers.Unconfined) { // Dispatchers.Unconfined를 사용해 실행되는 코루틴
    println("launch 코루틴 실행 스레드: ${Thread.currentThread().name}") // launch 코루틴이 실행되는 스레드 출력
  }
}
```

> runBlocking 코루틴 실행 스레드: DefaultDispatcher-worker-1 @coroutine#1
launch 코루틴 실행 스레드: DefaultDispatcher-worker-1 @coroutine#2
> 
- runBlocking은 Dispatchers.IO를 사용하도록 설정하고, launch 코루틴은 무제한 디스패처를 사용해 코루틴이 실행되는 스레드를 출력한다.
- runBlocking은 Dispatchers.IO의 공유 스레드풀의 스레드 중 하나를 사용해 실행되고, 내부에서 launch 코루틴은 runBlocking이 사용하던 스레드를 그대로 사용해 실행된다.
- 출력결과를 보면, 같은 스레드에서 실행된 것을 볼 수 있다. 이처럼 무제한 디스패처에서 코루틴이 실행되면 코루틴 빌더를 호출한 스레드에서 즉시 실행된다. CoroutineStart.UNDISPATCHED 옵션을 적용했을 때의 동작과 매우 비슷하다.
    
 <img width="660" alt="image" src="https://github.com/user-attachments/assets/3da9522d-6d1f-4da5-a5e8-29ae44fc8214" />
    
- 제한된 디스패처는 코루틴의 실행을 요청받으면 작업 대기열에 적재한 후 해당 디스패처에서 사용할 수 있는 스레드 중 하나로 보내 실행되도록 한다.
    
<img width="660" alt="image" src="https://github.com/user-attachments/assets/907dc273-e056-40d7-b149-7291c9189e7e" />

    
11.3.2.2. 중단 시점 이후의 재개는 코루틴을 재개하는 스레드에서 한다

- 무제한 디스패처는 일시 중단 전까지만 자신을 실행시킨 스레드에서 실행된다는 점을 기억하자. 무제한 디스패처를 사용하는 코루틴이 일시 중단 후 재개된다면 자신을 재개시키는 스레드에서 실행된다.
    
    ```kotlin
    fun main(): Unit =
      runBlocking {
        launch(Dispatchers.Unconfined) {
          println("일시 중단 전 실행 스레드: ${Thread.currentThread().name}")
          delay(100L)
          println("일시 중단 후 실행 스레드: ${Thread.currentThread().name}")
        }
      }
    ```
    
    > 일시 중단 전 실행 스레드: main <br>
    일시 중단 후 실행 스레드: kotlinx.coroutines.DefaultExecutor
  
- 일시 중단 전에는 main 스레드에서 실행되지만, 일시 중단 후 재개될 때는 DefaultExecutor라는 생소한 스레드에서 실행되고 있다. DefaultExecutor 스레드는 delay 함수를 실행하는 스레드로 delay 함수가 일시 중단을 종료하고 코루틴을 재개할 때 사용하는 스레드이다. 즉, 재개 이후의 launch 코루틴은 자신을 재개시킨 DefaultExecutor를 사용하게 된다.
- 어떤 스레드가 코루틴을 재개시키는지 예측하기는 매우 어렵기 때문에 일반적인 상황에서 무제한 디스패처를 사용하면 비동기 작업이 불안정해진다. 따라서 일반적인 상황에서 무제한 디스패처를 사용하는 것은 권장되지 않으며, 테스트 등의 매우 특수한 상황에서만 무제한 디스패처를 사용하도록 하자.

### 추가 자료. CoroutineStart.UNDISPATCHED와 무제한 디스패처의 차이

- 두 코루틴은 모두 호출자의 스레드에서 즉시 실행된다.
- CoroutineStart.UNDISPATCHED 옵션이 적용되는 코루틴은 자신이 실행되는 CoroutineDispatcher 객체를 사용해 재개되고, 무제한 디스패처를 사용해 실행되는 코루틴은 자신을 재개시킨 스레드를 사용해 재개된다.
    
    ```kotlin
    fun main() = runBlocking<Unit> {
      println("runBlocking 코루틴 실행 스레드: ${Thread.currentThread().name}") // runBlocking 코루틴이 실행되는 스레드 출력
      launch(start = CoroutineStart.UNDISPATCHED) { // CoroutineStart.UNDISPATCHED가 적용된 코루틴
        println("[CoroutineStart.UNDISPATCHED] 코루틴이 시작 시 사용하는 스레드: ${Thread.currentThread().name}")
        delay(100L)
        println("[CoroutineStart.UNDISPATCHED] 코루틴이 재개 시 사용하는 스레드: ${Thread.currentThread().name}")
      }.join()
      launch(context = Dispatchers.Unconfined) { // Dispatchers.Unconfined를 사용해 실행되는 코루틴
        println("[Dispatchers.Unconfined] 코루틴이 시작 시 사용하는 스레드: ${Thread.currentThread().name}")
        delay(100L)
        println("[Dispatchers.Unconfined] 코루틴이 재개 시 사용하는 스레드: ${Thread.currentThread().name}")
      }.join()
    }
    ```
    
    > runBlocking 코루틴 실행 스레드: main @coroutine#1 <br>
    [CoroutineStart.UNDISPATCHED] 코루틴이 시작 시 사용하는 스레드: main @coroutine#2 <br>
    [CoroutineStart.UNDISPATCHED] 코루틴이 재개 시 사용하는 스레드: main @coroutine#2 <br>
    [Dispatchers.Unconfined] 코루틴이 시작 시 사용하는 스레드: main @coroutine#3 <br>
    [Dispatchers.Unconfined] 코루틴이 재개 시 사용하는 스레드: kotlinx.coroutines.DefaultExecutor @coroutine#3
  
- runBlocking은 메인 스레드를 단일 스레드로 사용하는 제한된 디스패처를 자식 코루틴들에게 전달한다. 두 옵션 모두 메인 스레드에서 실행을 시작한다.
- 하지만, CoroutineStart.UNDISPATCHED 옵션이 적용된 코루틴은 runBlocking으로부터 전달받은 디스패처를 사용해 재개되고, 무제한 디스패처를 사용하는 코루틴은 자신을 재개시킨 스레드에서 재개되므로 delay를 실행하는데 사용하는 스레드에서 재개된다.
- CoroutineStart.UNDISPATCHED 옵션이 적용된 코루틴은 시작과 재개가 모두 메인 스레드에서 일어나고, Dispatchers.Unconfined를 사용해 실행된 코루틴은 시작은 메인 스레드에서 됐지만 재개는 delay를 실행하는 데 사용하는 DefaultExecutor 스레드에서 재개된 것을 볼 수 있다.

## 11.4. 코루틴의 동작 방식과 Continuation

### 11.4.1 Continuation Passing Style

- 코루틴은 코드를 실행 도중 일시 중단하고 다른 작업으로 전환한 후 필요한 시점에 다시 실행을 재개하는 기능을 지원한다. 코루틴이 일시 중단을 하고 재개하기 위해서는 코루틴의 실행 정보가 어딘가에 저장돼 전달해야 한다.
- 코틀린은 코루틴의 실행 정보를 저장하고 전달하는데 CPS(Continuation Passing Style)라고 불리는 방식을 채택하고 있다. (Continuation을 전달하는 스타일, 여기서 Continuation은 이어서 실행해야 하는 작업을 나타낸다.)
- 코틀린은 코루틴에서 이어서 실행해야 하는 작업 전달을 위해 Continuation 객체를 제공한다.
    
    ```kotlin
    public interface Continuation<in T> {
        /**
         * The context of the coroutine that corresponds to this continuation.
         */
        public val context: CoroutineContext
    
        /**
         * Resumes the execution of the corresponding coroutine passing a successful or failed [result] as the
         * return value of the last suspension point.
         */
        public fun resumeWith(result: Result<T>)
    }
    ```
    
    - Interface representing a continuation after a suspension point that returns a value of type T.
    - 일시 중단 지점 후에 이어서 실행해야 하는 작업을 나나태는 인터페이스로 T 타입의 값을 반환한다.
- Continuation 객체는 코루틴의 일시 중단 시점에 코루틴의 실행 상태를 저장하며, 다음에 실행해야 할 작업에 대한 정보가 포함된다.
- Continuation 객체가 코루틴의 실행에 매우 핵심적인 역할을 하지만, 지금까지 이 객체에 대한 언급이 없었다. 그 이유는 우리가 지금까지 다룬 코루틴의 API는 모두 고수준의 API이기 때문이다. 코루틴 라이브러리에서 제공하는 고수준 API는 Continuation 객체를 캡슐화해 사용자에게 노출하지 않지만 내부적으로는 코루틴의 일시 중단과 재개가 Continuation 객체를 통해 이루어진다.

### 11.4.2. 코루틴의 일시 중단과 재개로 알아보는 Continuation

- 코루틴에서 일시 중단이 일어나면 Continuation 객체에 실행 정보가 저장되며, 일시 중단된 코루틴은 Continuation 객체에 대해 resume 함수가 호출돼야 재개된다.
    
    ```kotlin
    fun main() = runBlocking<Unit> {
      println("runBlocking 코루틴 일시 중단 호출")
      suspendCancellableCoroutine<Unit> { continuation: CancellableContinuation<Unit> ->
        println("일시 중단 시점의 runBlocking 코루틴 실행 정보: ${continuation.context}")
      }
      println("일시 중단된 코루틴이 재개되지 않아 실행되지 않는 코드")
    }
    ```
    
    > runBlocking 코루틴 일시 중단 호출 <br>
    일시 중단 시점의 runBlocking 코루틴 실행 정보: [CoroutineId(1), "coroutine#1":BlockingCoroutine{Active}@51cdd8a, BlockingEventLoop@d44fc21] <br> 
   
- suspendCancellableCoroutine 함수가 호출되면 runBlocking 함수는 일시 중단되며, 실행 정보가 Continuation 객체에 저장돼 suspendCancellableCoroutine 함수의 람다식에서 CancellableContinuation 타입의 수신 객체로 제공된다. 위 코드에서는 이 수신 객체를 활용해 Continuation 객체 정보를 출력한다.
- 하지만 이 코드에는 한 가지 문제가 있다. 바로 실행이 종료되지 않는다는 점이다. Continuation 객체에 대한 재개가 호출되지 않아 runBlocking 코루틴이 재개되지 못했기 때문이다. runBlocking 코루틴을 재개시키기 위해서는 Continuation 객체에 대해 resume을 호출해야 한다.
    
    ```kotlin
    fun main() = runBlocking<Unit> {
      println("runBlocking 코루틴 일시 중단 호출")
      suspendCancellableCoroutine<Unit> { continuation: CancellableContinuation<Unit> ->
        println("일시 중단 시점의 runBlocking 코루틴 실행 정보: ${continuation.context}")
        continuation.resume(Unit) // 코루틴 재개 호출
      }
      println("runBlocking 코루틴 재개 후 실행되는 코드")
    }
    ```
    
    > runBlocking 코루틴 일시 중단 호출 <br>
    일시 중단 시점의 runBlocking 코루틴 실행 정보: [BlockingCoroutine{Active}@551aa95a, BlockingEventLoop@35d176f7] <br>
    runBlocking 코루틴 재개 후 실행되는 코드 <br>
    Process finished with exit code 0
  
- 실제로 우리가 자주 사용하는 delay 함수에서도 이와 비슷하게 코루틴을 일시 중단하고 특정 시점 이후 복구되도록 만든다.
    
    ```kotlin
    public suspend fun delay(timeMillis: Long) {
        if (timeMillis <= 0) return // don't delay
        return suspendCancellableCoroutine sc@ { cont: CancellableContinuation<Unit> ->
            // if timeMillis == Long.MAX_VALUE then just wait forever like awaitCancellation, don't schedule.
            if (timeMillis < Long.MAX_VALUE) {
                cont.context.delay.scheduleResumeAfterDelay(timeMillis, cont)
            }
        }
    }
    ```
    
    - delay 함수를 호출하면 suspendCancellableCoroutine이 호출되며, scheduleResumeAfterDelay 함수를 통해 일정 시간 이후에 Continuation 객체를 재개시킨다.
- 이처럼 Continuation 객체는 코루틴의 일시 중단 시점에 코루틴의 실행 정보를 저장하며, 재개 시 Continuation 객체를 사용해 코루틴의 실행을 복구할 수 있다.

### 11.4.3. 다른 작업으로부터 결과 수신해 코루틴 재개하기

- 코루틴 재개 시 다른 작업으로부터 결과를 수신받아야 하는 경우에는 suspendCancellableCoroutine 함수의 타입 인자에 결과로 반환받는 타입을 입력하면 된다.
    
    ```kotlin
    fun main() = runBlocking<Unit> {
      val result = suspendCancellableCoroutine<String> { continuation: CancellableContinuation<String> -> // runBlocking 코루틴 일시 중단 시작
        thread { // 새로운 스레드 생성
          Thread.sleep(1000L) // 1초간 대기
          continuation.resume("실행 결과") // runBlocking 코루틴 재개
        }
      }
      println(result) // 코루틴 재개 시 반환 받은 결과 출력
    }
    ```
    
    > 실행 결과
    > 
    > 
    > Process finished with exit code 0
    > 
- thread 함수가 새로운 스레드에서 코드 블록이 실행되도록 만들어 1초간 대기 후 continuation에 대한 resume을 “실행 결과”와 함께 호출하면 “실행 결과”는 result에 할당되고 runBlocking이 재개된다.
