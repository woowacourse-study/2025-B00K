# 11. 코루틴 심화 요약
## 1. 공유 상태를 사용하는 코루틴의 문제와 해결책
가변 변수 문제
여러 스레드에서 동시에 가변 변수에 접근하면 데이터 손실, 불일치 등 버그가 발생할 수 있다.

메모리 구조

JVM은 스택(스레드마다), 힙(공용)을 사용한다.

실제 하드웨어는 CPU 레지스터, CPU 캐시, 메인 메모리로 구분된다.

공유 상태의 메모리 가시성 문제
한 스레드가 변경한 값을 다른 스레드가 즉시 확인하지 못할 수 있다.

해결: @Volatile 어노테이션을 붙이면 CPU 캐시를 거치지 않고 값을 읽고 쓴다.

경쟁 상태(Race Condition) 문제
여러 스레드가 동시에 변수에 접근하면 값이 꼬일 수 있다.

해결 1: Mutex 사용

임계 영역을 만들어 코루틴이 동시에 접근하지 못하게 한다.

코루틴의 Mutex.lock은 일시 중단(suspend) 방식이라 스레드 블로킹이 없다.

withLock 함수 사용이 안전하다.

해결 2: 전용 스레드 사용

공유 상태 접근을 한 스레드(예: Dispatchers.IO.limitedParallelism(1))에서만 하게 한다.

해결 3: 원자성 있는 데이터 구조 사용

AtomicInteger 등 원자성 자료구조 사용.

여러 스레드가 동시에 접근해도 안전하게 값을 읽고 쓸 수 있다.

단, 연산이 실행 중이면 블로킹이 발생할 수 있다.

읽기/쓰기 분리 시 연산 손실이 발생할 수 있다.

## 2. 코루틴 실행 옵션
launch/async 빌더에서 start 인자로 실행 옵션(CoroutineStart)을 줄 수 있다.

DEFAULT: 기본값, 코루틴이 즉시 생성되고 실행 요청됨.

ATOMIC: 생성 상태일 때는 취소되지 않음.

UNDISPATCHED: 디스패처를 거치지 않고 즉시 호출자 스레드에서 실행됨.

LAZY: 명시적으로 start()를 호출해야 실행됨.

## 3. 무제한 디스패처
무제한 디스패처(Unconfined Dispatcher)

코루틴을 실행시킨 스레드에서 즉시 실행시킴.

일시 중단 후 재개 시, 재개한 스레드에서 실행된다.

## 4. 코루틴의 동작 방식과 Continuation
일반 코드는 작업이 스레드를 점유하며 순차적으로 실행됨.

코루틴은 일시 중단(suspend), **재개(resume)**가 가능하다.

Continuation Passing Style (CPS)

일시 중단 시점의 남은 작업을 Continuation 객체에 저장

resumeWith가 호출되면 남은 작업을 이어서 실행

고수준 코루틴 API는 Continuation을 직접 노출하지 않는다.

suspendCancellableCoroutine을 사용하면 Continuation을 직접 다루는 코드 작성 가능

