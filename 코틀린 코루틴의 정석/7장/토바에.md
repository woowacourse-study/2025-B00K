# 구조화된 동시성
구조화된 동시성의 원칙
- 비동기 작업을 구조화함으로써 비동기 프로그래밍을 보다 안정적이고 예측할 수 있게 만드는 원칙


구조화된 동시성의 원칙을 사용하면 부모와 자식 관계로 구조화함으로써 코루틴이 보다 안전하게 관리되고 제어될 수 있다.

#### 부모-자식 관계로 구조화하는 방법
부모 코루틴을 만드는 코루틴 빌더의 람다식 속에서 새로운 코루틴 빌더를 호출한다.

```
fun main() = runBlocking {
    launch {
        launch {
            println("자식 코루틴 실행")
        }
    }
}
```

안쪽 코루틴이 바깥쪽의 자식 코루틴이 된다.
같은 맥락에서 바깥쪽 launch는 runBlocking의 자식 코루틴이 된다. 

#### 구조화된 코루틴의 대표적인 특징
1. 부모 코루틴의 실행 환경이 자식 코루틴에게 상속된다.
2. 작업을 제어하는 데 사용된다.
3. 부모 코루틴이 취소되면 자식 코루틴도 취소된다.
4. 부모 코루틴은 자식 코루틴이 완료될 때까지 대기한다.
5. CoroutineScope를 사용해 코루틴이 실행되는 범위를 제한할 수 있다.


## 실행 환경 상속
Coroutinecontext가 구조화된 코루틴 사이에 어떻게 전달되는지

### 부모 코루틴의 실행 환경 상속
부모 코루틴은 자식 코루틴에게 실행 환경을 상속한다.
부모 코루틴이 자식 코루틴을 생성하면 부모 코루틴의 CoroutineContext가 자식 코루틴에게 전달된다 -> 실행 환경을 상속한다.
```
fun main() = runBlocking<Unit> {
    val coroutineContext = newSingleThreadContext("MyThread") + CoroutineName("CoroutineA")
    launch (coroutineContext) {
        println("[${Thread.currentThread().name}] 부모 코루틴 실행")
        launch {
            println("[${Thread.currentThread().name}] 자식 코루틴 실행")
        }
    }
}
```
바깥쪽 launch로 생성된 부모 코루틴은 coroutineContext에 설정된 대로 MyThread 스레드를 사용해 실행되고 코루틴 이름이 CoroutineA로 설정된다.
coroutineContext가 설정되지 않은 자식 코루틴도 MyThread 스레드를 사용하고 코루틴 이름이 CoroutineA이다.
-> 부모 코루틴의 실행 환경을 담는 CoroutineContext 객체가 자식 코루틴에게 상속되기 때문


### 실행 환경 덮어씌우기
부모 코루틴의 모든 실행 환경이 항상 자식 코루틴에게 상속되지는 않는다.
자식 코루틴을 생성하는 코루틴 빌더 함수로 새로운 CoroutineContext 객체가 전달되면 부모 코루틴에게서 전달받은 CoroutineContext 구성 요소들은 자식 코루틴 빌더 함수로 전달된 CoroutineContext 객체의 구성 요소들로 덮어씌워진다.
```
fun main() = runBlocking<Unit> {
    val coroutineContext = newSingleThreadContext("MyThread") + CoroutineName("ParentCoroutine")
    launch (coroutineContext) {
        println("[${Thread.currentThread().name}] 부모 코루틴 실행")
        launch (CoroutineName("ChildCoroutine")) {
            println("[${Thread.currentThread().name}] 자식 코루틴 실행")
        }
    }
}
```




