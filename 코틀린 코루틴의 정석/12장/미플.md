# 12장 - 코루틴 단위 테스트

## 12.1. 단위 테스트 기초

### 12.1.1. 단위 테스트란 무엇인가?

- 단위(Unit)의 의미부터 알아보자. 단위란 명확히 정의된 역할의 범위를 갖는 코드의 집합으로, 소프트웨어의 기능을 담는 코드 블록을 나타낸다. 즉, 정의된 동작을 실행하는 개별 함수나 클래스 또는 모듈이 모두 단위가 될 수 있다.
- OOP에서 단위는 좀 더 명확한 의미를 가진다. 객체 지향 프로그래밍이란 책임을 객체에 할당하고, 객체 간의 유연한 협력관계를 구축하는 것을 의미한다. 즉, 객체 지향 프로그래밍에서 책임을 할당받는, 다시 말해 소프트웨어의 기능을 담는 역할은 객체가 한다. 따라서 객체 지향 프로그래밍에서 테스트 대상이 되는 단위는 주로 객체가 된다.
- 객체가 예상한 대로 동작하는지 확인하는 방법은 다양하다. 단순히, 결괏값이 제대로 반환되는지 확인할 수도 있지만 해당 객체가 가진 상태가 잘 변화하는지, 함수 호출 시 해당 객체가 의존성을 가진 다른 객체와 제대로 상호 작용하는지 등을 확인해 객체가 예상한 대로 동작하는지 확인할 수 있다.

### 12.1.5. 테스트 더블을 사용해 의존성 있는 객체 테스트하기

- 다른 객체들과 의존성이 있는 객체를 테스트하는 방법을 알아보자.
    
    ```kotlin
    class UserProfileFetcher(
        private val userNameRepository: UserNameRepository,
        private val userPhoneNumberRepository: UserPhoneNumberRepository
    ) {
        fun getUserProfileById(id: String): UserProfile {
            // 유저의 이름을 UserNameRepository로부터 가져옴
            val userName = userNameRepository.getNameByUserId(id)
            // 유저의 전화번호를 UserPhoneNumberRepository로부터 가져옴
            val userPhoneNumber = userPhoneNumberRepository.getPhoneNumberByUserId(id)
            return UserProfile(
                id = id,
                name = userName,
                phoneNumber = userPhoneNumber
            )
        }
    }
    ```
    
- UserProfileFetcher 객체에 대한 테스트 코드를 만들려 하는데, UserNameRepository 인터페이스와 UserPhoneNumberRepository 인터페이스에 대한 구현체가 없어 쉽지 않다는 것을 알 수 있다.
- 해당 인터페이스의 실제 구현체를 사용한다 하더라도 UserProfileFetcher 객체에 대한 테스트 케이스 작성에 이들의 실제 구현체를 사용하면 UserProfileFetcher 객체의 테스트가 UserNameRepository나 UserPhoneNumberRepository의 구현체에 영향을 받기 때문에 제대로 된 테스트를 할 수 없다.

12.1.5.1. 테스트 더블을 통한 객체 모방

- 다른 객체와의 의존성을 가진 객체를 테스트하기 위해서는 테스트 더블이 필요하다. 테스트 더블은 객체에 대한 대체물을 뜻하며, 객체의 행동을 모방하는 객체를 만드는 데 사용한다. 만약, 테스트 대상 객체가 다른 객체에 대한 의존성이 있다면 의존성 있는 객체를 모방하는 객체를 만들어 특정 객체에 대한 테스트가 의존성 있는 객체의 구체적인 구현에 의존하는 문제를 해결할 수 있다.
    
 <img width="800" alt="image" src="https://github.com/user-attachments/assets/ff748eb7-ac39-42f8-8ae2-e58c86287061" />

    
- 테스트 더블의 종류에는 대표적으로 Stub, Mock, Fake의 3가지가 있고, 이외에도 Dummy, Spy 등 종류가 매우 많다. 여기서는 Stub, Fake 정도만 다룬다.

### 스텁(Stub)

- 스텁 객체는 미리 정의된 데이터를 반환하는 모방 객체로 반환값이 없는 동작은 구현하지 않으며, 반환값이 있는 동작만 미리 정의된 데이터를 반환하도록 구현한다.
- 예를 들어, UserNameRepository를 스텁으로 만든 StubUserNameRepository는 다음과 같다.
    
    ```kotlin
    interface UserNameRepository {
        fun saveUserName(id: String, name: String)
        fun getNameByUserId(id: String): String
    }
    ```
    
    ```kotlin
    // 유연하지 않은 StubUserNameRepository
    class StubUserNameRepository : UserNameRepository {
        private val userNameMap = mapOf<String, String>(
            "0x1111" to "홍길동",
            "0x2222" to "조세영"
        )
    
        override fun saveUserName(id: String, name: String) {
            // 구현하지 않는다.
        }
    
        override fun getNameByUserId(id: String): String {
            return userNameMap[id] ?: ""
        }
    }
    ```
    
    - getNameByUserId를 호출하면 userNameMap에 미리 정의한 값들을 반환할 수 있도록 한다. 하지만, 이렇게 만든 스텁 객체는 userNameMap이 고정되어 있기 때문에 유연하지 못하다. 이를 위해서는 userNameMap을 주입받도록 만들면 된다.
    
    ```kotlin
    // 유연한 StubUserNameRepository
    class StubUserNameRepository(
        private val userNameMap: Map<String, String> // 데이터 주입
    ) : UserNameRepository {
        override fun saveUserName(id: String, name: String) {
            // 구현하지 않는다.
        }
    
        override fun getNameByUserId(id: String): String {
            return userNameMap[id] ?: ""
    }
    ```
    

### 페이크 (Fake)

- 페이크 객체는 실제 객체와 비슷하게 동작하도록 구현된 모방 객체이다. 예를들어 UserPhoneNumberRepository 인터페이스의 실제 구현체가 로컬 데이터베이스를 사용해 유저의 전화번호를 저장한다고 가정해 보자.
    
    ```kotlin
    interface UserPhoneNumberRepository {
        fun saveUserPhoneNumber(id: String, phoneNumber: String)
        fun getPhoneNumberByUserId(id: String): String
    }
    ```
    
    ```kotlin
    class FakeUserPhoneNumberRepository : UserPhoneNumberRepository {
      private val userPhoneNumberMap = mutableMapOf<String, String>()
    
      override fun saveUserPhoneNumber(id: String, phoneNumber: String) {
        userPhoneNumberMap[id] = phoneNumber
      }
    
      override fun getPhoneNumberByUserId(id: String): String {
        return userPhoneNumberMap[id] ?: ""
      }
    }
    ```
    
    - FakeUserPhoneNumberRepository 객체는 유저의 전화번호를 로컬 데이터베이스 대신 인메모리에 저장해 실제 객체처럼 동작할 수 있도록 만든다.

- 이렇게 만들어진 테스트 더블인 StubUserNameRepository, FakeUserPhoneNumberRepository를 사용하면 UserProfileFetcher 객체에 대한 테스트가 가능해진다.

12.1.5.2. 테스트 더블을 사용한 테스트

```kotlin
class UserProfileFetcher(
    private val userNameRepository: UserNameRepository,
    private val userPhoneNumberRepository: UserPhoneNumberRepository
) {
    fun getUserProfileById(id: String): UserProfile {
        // 유저의 이름을 UserNameRepository로부터 가져옴
        val userName = userNameRepository.getNameByUserId(id)
        // 유저의 전화번호를 UserPhoneNumberRepository로부터 가져옴
        val userPhoneNumber = userPhoneNumberRepository.getPhoneNumberByUserId(id)
        return UserProfile(
            id = id,
            name = userName,
            phoneNumber = userPhoneNumber
        )
    }
}
```

- UserProfileFetcher 클래스를 다시 한 번 살펴보자. “0x1111” 아이디에 대해 getUserProfileById를 호출했을 때 “홍길동”을 반환한다면 getUserProfileById로 가져온 유저 프로필에도 이름이 홍길동으로 설정돼 있는지 확인하는 테스트를 작성해보자
- 이를 위해서는 StubUserNameRepository에 대해 getNameByUserId(”0x1111”)이 “홍길동”을 반환하다록 설정해야 하며, UserPhoneNumberRepository 자리에는 실제와 같이 동작할 수 있도록 FakeUserPhoneNumberRepository 객체를 주입한다.
    
    ```kotlin
    class UserProfileFetcherTest {
      @Test
      fun `UserNameRepository가 반환하는 이름이 홍길동이면 UserProfileFetcher에서 UserProfile를 가져왔을 때 이름이 홍길동이어야 한다`() {
        // Given
        val userProfileFetcher = UserProfileFetcher(
          userNameRepository = StubUserNameRepository(
            userNameMap = mapOf<String, String>(
              "0x1111" to "홍길동",
              "0x2222" to "조세영"
            )
          ),
          userPhoneNumberRepository = FakeUserPhoneNumberRepository()
        )
    
        // When
        val userProfile = userProfileFetcher.getUserProfileById("0x1111")
    
        // Then
        assertEquals("홍길동", userProfile.name)
      }
    }
    ```
    

- 이번에는 UserPhoneNumberRepository 객체에 유저의 휴대폰 번호가 저장되어 있는 경우 UserProfileFetcher를 사용해 유저 프로필을 가져오면 저장된 휴대폰 번호가 반환되는지 확인하는 테스트를 작성해보자.
- 이를 위해 테스트 환경 설정 시 FakeUserPhoneNumberRepository 객체에 대해 saveUserPhoneNumber를 호출해 “0x1111” 아이디에 대응하는 휴대폰 번호를 “010-xxxx-xxxx”로 저장해 놔야 한다.
    
    ```kotlin
    @Test
    fun `UserPhoneNumberRepository에 휴대폰 번호가 저장되어 있으면, UserProfile를 가져왔을 때 해당 휴대폰 번호가 반환되어야 한다`() {
      // Given
      val userProfileFetcher = UserProfileFetcher(
        userNameRepository = StubUserNameRepository(
          userNameMap = mapOf<String, String>(
            "0x1111" to "홍길동",
            "0x2222" to "조세영"
          )
        ),
        userPhoneNumberRepository = FakeUserPhoneNumberRepository().apply {
          this.saveUserPhoneNumber("0x1111", "010-xxxx-xxxx")
        }
      )
    
      // When
      val userProfile = userProfileFetcher.getUserProfileById("0x1111")
    
      // Then
      assertEquals("010-xxxx-xxxx", userProfile.phoneNumber)
    }
    ```
    

- 이렇게 테스트 더블을 활용해 다른 객체에 의존성이 있는 객체를 테스트할 수 있다. 물론, 테스트를 위해 매번 인터페이스를 구현해 테스트 더블을 만드는 것은 매우 비효율적이다. 이런 문제 해결을 위해 테스트 더블을 쉽게 만들 수 있게 하는 Mockito나 mockK 같은 라이브러리들이 출시됐다.
- 하지만, 이 라이브러리들을 사용하기 위해서는 추가적인 학습이 필요하다.
- 실제 코드상의 객체는 더 복잡한 상호 작용을 하는 경우가 많다. 따라서 실제로는 단위 테스트 시 단순히 테스트 대상 객체가 반환한 값을 비교하는 것뿐만 아니라 테스트 대상 객체의 상태가 어떻게 변화하는지, 테스트 대상 객체가 의존성 있는 객체와 어떻게 상호 작용하는지 등에 대한 테스트를 진행한다.

## 12.2. 코루틴 단위 테스트 시작하기

### 12.2.1. 코루틴 테스트 작성하기

- 코루틴에 대한 단위 테스트를 작성하기 위해서는 테스트 대상 객체가 필요하다.
    
    ```kotlin
    class RepeatAddUseCase {
      suspend fun add(repeatTime: Int): Int = withContext(Dispatchers.Default) {
        var result = 0
        repeat(repeatTime) {
          result += 1
        }
        return@withContext result
      }
    }
    ```
    
    - add 일시 중단 함수는 사용하는 스레드를 CPU 바운드 작업을 위한 백그라운드 스레드로 전환한 후 매개변수로 입력된 repeatTime만큼 result에 1을 반복해 더하고 반환한다.
    
    ```kotlin
    class RepeatAddUseCaseTest {
        @Test
        fun `100번 더하면 100이 반환된다`() {
            // Given
            val repeatAddUseCase = RepeatAddUseCase()
    
            // When
            val result = repeatAddUseCase.add(100)
    
            // Then
            assertThat(result).isEqualTo(100)
        }
    }
    ```
    
    - repeatTime 매개변수로 100을 넘긴 후 반환값이 100과 동일한지 확인하는 테스트를 작성할 수 있다.
- 하지만, add 함수는 일시 중단 함수인데, 테스트 함수는 일반 함수이기 때문에 컴파일 에러가 발생한다
    
 <img width="800" alt="image" src="https://github.com/user-attachments/assets/d4531a64-33ed-4f58-88ea-4ba56b71ad1d" />

    
- 이 문제를 해결하려면 테스트 함수를 runBlocking으로 감싸면 된다.
    
    ```kotlin
    class RepeatAddUseCaseTest {
        @Test
        fun `100번 더하면 100이 반환된다`() {
            runBlocking {
                // Given
                val repeatAddUseCase = RepeatAddUseCase()
    
                // When
                val result = repeatAddUseCase.add(100)
    
                // Then
                assertThat(result).isEqualTo(100)
            }
        }
    }
    ```
    
  <img width="600" alt="image" src="https://github.com/user-attachments/assets/044489fd-deab-49aa-a8dc-7a3be27d64e2" />

    
- 하지만, runBlocking을 사용해 테스트를 진행하면 runBlocking 함수의 한계로 인해 문제가 생긴다.

### 12.2.2. runBlocking을 사용한 테스트의 한계

- runBlocking 함수를 사용한 테스트에서 실행에 오랜 시간이 걸리는 일시 중단 함수를 실행하면 문제가 나타난다.
    
    ```kotlin
    class RepeatAddWithDelayUseCase {
        suspend fun add(repeatTime: Int): Int {
            var result = 0
            repeat(repeatTime) {
                delay(100L)
                result += 1
            }
            return result
        }
    }
    ```
    
    - add 일시 중단 함수는 반복해 더하는 과정에서 100밀리간 일시 중단 후 더하기를 반복한다.
    
    ```kotlin
     @Test
      fun `100번 더하면 100이 반환된다`() {
        // Given
        val testCoroutineScheduler = TestCoroutineScheduler()
        val testDispatcher = StandardTestDispatcher(testCoroutineScheduler)
    
        val repeatAddUseCase = RepeatAddWithDelayUseCase()
    
        // When
        var result = 0
        CoroutineScope(testDispatcher).launch {
          result = repeatAddUseCase.add(100)
        }
        testCoroutineScheduler.advanceUntilIdle()
    
        // Then
        assertEquals(100, result)
      }
    ```
    
 <img width="600" alt="image" src="https://github.com/user-attachments/assets/93848ad5-78db-4191-b7c3-a5b37b2b7625" />

    
    - 테스트가 10초가 걸린 것을 볼 수 있다.
- 테스트가 정상적으로 실행돼 통과하지만, 테스트 하나를 실행하는 데 걸린 시간이 10초가 넘는다. repeatTime 인자로 10,000이 들어온다면 1000초가 걸렸을 것이다.
- 이렇게 오래 걸리는 테스트는 사실상 활용되지 않는다. 좋은 테스트를 작성하는 원칙 중 하나는 테스트에 걸리는 시간을 짧게 해서 테스트를 부담 없이 실행할 수 있도록 하는 것이다.
- 코루틴 테스트 라이브러리는 가상 시간에서 테스트를 진행할 수 있도록 코루틴 스케줄러를 제공한다.

## 12.3. 코루틴 테스트 라이브러리

### 12.3.1. 코루틴 테스트 라이브러리 의존성 설정하기

```kotlin
testImplementation("org.jetbrains.kotlinx:kotlinx-coroutines-test:X.Y.Z")
```

### 12.3.2. TestCoroutineScheduler 사용해 가상 시간에서 테스트 진행하기

12.3.2.1. advanceTimeBy 사용해 가상 시간 흐르게 만들기

- TestCoroutineScheduler의 advanceTimeBy 함수를 호출하면 함수의 인자로 입력된 값만큼 가상 시간이 밀리초 단위로 흐르게 된다. 가상 시간이 얼마나 흘렀는지 확인하고 싶으면 TestCoroutineScheduler 객체의 currentTime 프로퍼티를 사용하면 된다.
    
    ```kotlin
    @OptIn(ExperimentalCoroutinesApi::class)
    @Test
    fun `가상 시간 조절 테스트`() =
        runTest {
            // 테스트 환경 설정
            TestCoroutineScheduler()
    
            advanceTimeBy(5000L) // 가상 시간에서 5초를 흐르게 만듦 : 현재 시간 5초
            assertEquals(5000L, currentTime) // 현재 시간이 5초임을 단언
            advanceTimeBy(6000L) // 가상 시간에서 6초를 흐르게 만듦 : 현재 시간 11초
            assertEquals(11000L, currentTime) // 현재 시간이 11초임을 단언
            advanceTimeBy(10000L) // 가상 시간에서 10초를 흐르게 만듦 : 현재 시간 21초
            assertEquals(21000L, currentTime) // 현재 시간이 21초임을 단언
        }
    ```
    
    - TestCoroutineScheduler 객체를 생성한 후 해당 객체에 대해 advanceTimeBy(5000L)을 호출해 가상시간을 5초 증가시킨다. 따라서, currentTime = 5000L assert문이 통과한다. 그다음 6초, 11초도 정상적으로 증가한다.

13.3.2.2. TestCoroutineScheduler와 StandardTestDispatcher 사용해 가상 시간 위에서 테스트 진행하기

- TestCoroutineScheduler 객체는 테스트용 CorotuineDispatcer 객체인 TestDispatcher를 만드는 StandardTestDispatcher와 함께 사용할 수 있다. StandardTestDispatcher 함수에 TestCoroutineScheduler 객체를 전달하면 생성되는 TestDispatcher 객체가 가상 시간을 사용하도록 만들 수 있다.
    
    ```kotlin
    fun `가상 시간 위에서 테스트 진행`() =
          runTest {
              // 테스트 환경 설정
              val testCoroutineScheduler = TestCoroutineScheduler()
              val testDispatcher: TestDispatcher =
                  StandardTestDispatcher(scheduler = testCoroutineScheduler)
              val testCoroutineScope = CoroutineScope(context = testDispatcher)
    
              // Given
              var result = 0
    
              // When
              testCoroutineScope.launch {
                  delay(10000L) // 10초간 대기
                  result = 1
                  delay(10000L) // 10초간 대기
                  result = 2
                  println(Thread.currentThread().name)
              }
    
              // Then
              assertEquals(0, result)
              testCoroutineScheduler.advanceTimeBy(5000L) // 가상 시간에서 5초를 흐르게 만듦 : 현재 시간 5초
              assertEquals(0, result)
              testCoroutineScheduler.advanceTimeBy(6000L) // 가상 시간에서 6초를 흐르게 만듦 : 현재 시간 11초
              assertEquals(1, result)
              testCoroutineScheduler.advanceTimeBy(10000L) // 가상 시간에서 10초를 흐르게 만듦 : 현재 시간 21초
              assertEquals(2, result)
          }
    ```
    
    - testDispatcher 객체를 사용하는 CoroutineScope 객체를 생성하고, 이 객체는 testCoroutineScope를 통해 참조된다.
    - testCoroutineScope에서 launch 코루틴을 실행해 10초간 대기 후 result를 1로 업데이트 시키고 10초를 또 기다린 후 2로 업데이트시킨다.
    - advanceTimeBy를 통해 가상 시간을 흐르게 함으로써 result값을 테스트할 수 있다.
        
 <img width="800" alt="image" src="https://github.com/user-attachments/assets/9b9b4c8d-0baf-49f8-b358-64d03d1bbad1" />

- 물론, 테스트 시 이렇게 직접 시간을 컨트롤하는 경우는 거의 없지만, 가상 시간을 직접 제어해보는 것이 이후 코루틴 테스트 라이브러리의 기능을 이해하는데 도움이 된다.

12.3.2.3. advanceUntilIdle 사용해 모든 코루틴 실행하기

- 테스트가 제대로 실행되기 위해서는 테스트 대상 코드가 모두 실행되고 나서 assert가 실행되어야 한다. TestCoroutineScheduler는 이 객체를 사용하는 모든 디스패처와 연결된 작업이 모두 완료될 때까지 가상 시간을 흐르게 만드는 advanceUntilIdle 함수를 제공한다.
    
    ```kotlin
    @Test
    fun `advanceUntilIdle의 동작 살펴보기`() {
        // 테스트 환경 설정
        val testCoroutineScheduler = TestCoroutineScheduler()
        val testDispatcher: TestDispatcher = StandardTestDispatcher(scheduler = testCoroutineScheduler)
        val testCoroutineScope = CoroutineScope(context = testDispatcher)
    
        // Given
        var result = 0
    
        // When
        testCoroutineScope.launch {
            delay(10_000L) // 10초간 대기
            result = 1
            delay(10_000L) // 10초간 대기
            result = 2
        }
        testCoroutineScheduler.advanceUntilIdle() // testCoroutineScope 내부의 코루틴이 모두 실행되게 만듦
    
        // Then
        assertEquals(2, result)
    }
    ```
    
    - 가상 시간을 흐르게 할 때 advanceTimeBy 대신 advanceUntilIdle 함수를 호출한다.
    - 여기서는 testCoroutineScheduler와 연결된 코루틴인 launch가 모두 호출될 때까지 가상 시간이 흐르게 되어 테스트가 통과하게 된다.
- TestCoroutineScheduler 객체의 advanceUntilIdle 함수가 실행되면 TestCoroutineScheduler 객체를 사용한 모든 코루틴 작업이 실행 완료될 때까지 가상 시간이 흐르게 된다.

## 12.3.3. TestCoroutineScheduler를 포함하는 StandardTestDispatcher

- StandardTestDispatcher 함수에는 기본적으로 TestCoroutineScheduler 객체를 생성하는 부분이 포함되어 있어 직접 생성할 필요가 없다.
    
    ```kotlin
    public fun StandardTestDispatcher(
        scheduler: TestCoroutineScheduler? = null,
        name: String? = null
    ): TestDispatcher = StandardTestDispatcherImpl(
        scheduler ?: TestMainDispatcher.currentTestScheduler ?: TestCoroutineScheduler(), name)
    ```
    
- StandardTestDispatcher 함수가 호출됐을 때 scheduler 인자로 아무것도 전달되지 않으면 먼저 TestMainDispatcher.currentTestScheduler가 있는 지 확인하고, 없으면 TestCoroutineScheduler()를 호출해 TestCoroutineScheduler 객체를 생성한다.
- 즉, StandardTestDispatcher 함수를 사용하면 내부에서 자동으로 TestCoroutineScheduler 객체가 생성된다.
- StandardTestDispatcher()를 통해 생성되는 TestDispatcher 객체에서 TestCoroutineScheduler 객체를 사용하려면 TestDispatcher 객체의 scheduler 프로퍼티를 통해 TestCoroutineScheduler 객체에 접근해 사용하면 된다.
    
    ```kotlin
    val testDispatcher: TestDispatcher = StandardTestDispatcher()
    val testCoroutineScope = CoroutineScope(context = testDispatcher)
    ```
    
    - 더 이상 TestCoroutineScheduler 객체가 생성되는 부분을 코드에 포함하지 않아 코드가 간결해진다.

### 12.3.4. TestScope 사용해 가상 시간에서 테스트 진행하기

- TestCoroutineScheduler 객체를 생성하는 부분을 제거했지만 여전히 TestDispatcher 객체를 생성하고, 이 객체를 CoroutineScope 함수로 감싸서 사용해야 한다.
- 매번 TestDisptacher 객체를 CoroutineScope 함수로 감싸서 사용하는 것은 불편하다. 이를 해결하기 위해 코루틴 테스트 라이브러리는 TestScope 함수를 제공한다. TestScope 함수를 호출하면 내부에 TestDispatcher 객체를 가진 TestScope 객체가 반환된다. 또한, TestScope에 대한 확장 함수를 통해 TestCoroutineScheduler 객체의 함수들과 프로퍼티를 TestScope 객체가 직접 호출할 수 있도록 한다.
    
    ```kotlin
    fun `TestScope 사용하기`() {
        // 테스트 환경 설정
        val testCoroutineScope: TestScope = TestScope()
    
        // Given
        var result = 0
    
        // When
        testCoroutineScope.launch {
            delay(10000L) // 10초간 대기
            result = 1
            delay(10000L) // 10초간 대기
            result = 2
        }
    
        testCoroutineScope.advanceUntilIdle() // testCoroutineScope 내부의 코루틴이 모두 실행되게 만듦
        assertEquals(2, result)
    }
    ```
    
    - 이 테스트에서는 TestDispatcher 객체를 생성해 이를 CoroutineScope로 감싸는 대신 TestScope 함수만 호출하면 돼 코드가 간결해진다.
- TestScope 함수는 기본적으로 StandardTestDispatcher 함수로 생성되는 TestDispatcher 객체를 포함한다.
    
 <img width="800" alt="image" src="https://github.com/user-attachments/assets/02d24d3e-d06a-441d-b616-09bf91d699e9" />
    

### 12.3.5. runTest 사용해 테스트 만들기

12.3.5.1. runTest 사용해 테스트 만들기

- runTest 함수는 TestScope 객체를 사용해 코루틴을 실행시키고, 그 코루틴 내부에서 일시 중단 함수가 실행되더라도 작업이 곧바로 실행 완료될 수 있도록 가상 시간을 흐르게 만드는 기능을 가진 코루틴 빌더이다.
- 테스트를 하고싶은 코드 블록을 runTest 함수의 람다식에서 실행하면 runBlocking 함수로 만들어지는 코루틴과 유사하게 동작하지만 자연되는 부분을 건너뛰는 코루틴이 만들어진다.
    
    ```kotlin
    @Test
    fun `runTest 사용하기`() {
      // Given
      var result = 0
    
      // When
      runTest { // this: TestScope
        delay(10000L) // 10초간 대기
        result = 1
        delay(10000L) // 10초간 대기
        result = 2
      }
    
      // Then
      assertEquals(2, result)
    }
    ```
    
    - 실제 테스트를 실행하는데 100밀리초정도밖에 걸리지 않는다. runTest가 아닌 runBlocking 함수로 감싸졌다면 실제로는 20초가 걸렸을 것이다.
- 지금까지 내용을 정리하면 runTest 함수는 TestScope 함수를 포함하고, TestScope 함수는 StandardTestDisptacher 함수를 포함하고 StandardTestDisptacher 함수는 TestCoroutineScheduler 함수를 포함한다.
  
  <img width="600" alt="image" src="https://github.com/user-attachments/assets/4998e133-b42a-449c-8608-808c5c40b7e8" />


12.3.5.2.  runTest로 테스트 전체 감싸기

- 위의 코드는 테스트를 원하는 코드부분만 runTest 함수로 감쌌지만, 일반적으로는 runTest 함수를 사용해 테스트 전체를 감싼다.
    
    ```kotlin
    @Test
    fun `runTest로 테스트 감싸기`() = runTest {  // this: TestScope
      // Given
      var result = 0
    
      // When
      delay(10000L) // 10초간 대기
      result = 1
      delay(10000L) // 10초간 대기
      result = 2
    
      // Then
      assertEquals(2, result)
    }
    ```
    
- 이렇게 모든 테스트를 runTest 함수로 감싸는 이유는 테스트 환경을 설정하는 부분에서도 일시 중단 함수가 호출될 수도 있고, 결과를 비교하는 부분에서도 일시 중단 함수가 호출될 수 있기 때문이다. runTest 함수로 이 부분들을 감싸면 각 부분에서 일시 중단 함수가 호출되더라도 일시 중단되는 시간을 가상 시간을 통해 빠르게 흐르게 만들 수 있다.
    
    ```kotlin
    @Test
    fun testSetupAndAssertWithRunTest() = runTest {
        // 1. 테스트 환경 설정
        delay(2000) // 예: DB 초기화, API Mock 설정 (가상 시간 즉시 진행)
    
        // 2. 함수 실행
        val result = fetchData() // 3초 대기 (가상 시간 즉시 진행)
    
        // 3. 결과 비교 단계에서도 suspend 호출 가능
        delay(1000) // 예: 비동기 검증 절차 (가상 시간 즉시 진행)
    
        assertEquals("Hello", result)
    }
    ```
    
    - fetchData말고도 위와 같이 테스트 환경 설정, 결과 비교 단계에서도 일시 중단 함수가 호출될 수 있기 때문

12.3.5.3. runTest 함수의 람다식에서 TestScope 사용하기

- runTest 함수는 람다식에서 TestScope 객체를 수신 객체로 갖기 때문에 this를 통해 TestScope 객체에 접근할 수 있다. 따라서, runTest 함수의 람다식에서는 TestScope 객체가 사용할 수 있는 advanceTimeBy, advanceUntilIdle 같은 확장 함수들과 currentTime 확장 프로퍼티를 모두 사용할 수 있다.
- runTest 함수의 람다식 내부에서 delay(10000L)가 호출되면 advanceUntilIdle 함수가 호출되지 않아도 가상 시간 10초가 자동으로 흐르게 된다. 그렇다면 runTest 안에서 advanceTimeBy나 advanceUntilIdle 함수는 언제 사용할 수 있을까?
- 바로 **runTest의 TestScope 내부에서 새로운 코루틴이 실행될 때** 해당 코루틴이 모두 실행 완료될 때까지 가상 시간을 흐르게 하는 데 사용할 수 있다.
    
    ```kotlin
    @Test
    fun `runTest 내부에서 advanceUntilIdle 사용하기`() = runTest {  // this: TestScope
      var result = 0
      launch {
        delay(1000L)
        result = 1
      }
    
      println("가상 시간: ${this.currentTime}ms, result = ${result}")
      advanceUntilIdle()
      println("가상 시간: ${this.currentTime}ms, result = ${result}")
    }
    ```
    
    > 가상 시간: 0ms, result = 0
    가상 시간: 1000ms, result = 1
    > 
    - runTest 내부에서 새로운 launch 코루틴이 새롭게 생성된다. runTest 함수는 runTest 함수로 생성된 내부에서 실행된 일시 중단 함수에 대해서만 가상 시간이 흐르게 만들며, launch 코루틴에 대해서는 자동으로 시간을 흐르게 하지 않는다. 이럴 때 advanceUntilIdle()를 호출해야만 runTest 블록 내부에서 새로 생성된 코루틴들이 실행 완료될 때까지 시간이 흐른다.
    - runTest 함수가 내부에서 새로 생성된 코루틴에 대해 가상 시간을 흐르게 만들어 즉시 실행 완료시키면 코루틴이 순차적으로 실행되므로 병렬 환경에서의 코루틴 테스트가 제대로 이뤄질 수 없다. 따라서 runTest 내부에서 모든 코루틴이 생성되고 나서 advanceUntilIdle을 호출해 생성된 모든 코루틴이 함께 실행될 수 있도록 해야 제대로 테스트가 이뤄질 수 있다.
- 만약, runtTest 코루틴의 자식 코루틴을 생성하고 해당 코루틴에 대해 join을 호출하면 advanceUntilIdle을 호출하지 않더라도 runTest 코루틴의 가상 시간이 흐른다. 그 이유는 join 함수의 호출이 runTest 코루틴을 일시 중단시키기 때문이다.
    
    ```kotlin
    @Test
      fun `runTest 내부에서 join 사용하기`() = runTest {  // this: TestScope
        var result = 0
        launch {
          delay(1000L)
          result = 1
        }.join()
    
        println("가상 시간: ${this.currentTime}ms, result = ${result}") 
      }
    ```
    
    > 가상 시간: 1000ms, result = 1
    > 

## 12.4. 코루틴 단위 테스트 만들어 보기

## 12.5. 코루틴 테스트 심화

### 12.5.1. 함수 내부에서 새로운 코루틴을 실행하는 객체에 대한 테스트

- 일시 중단 함수가 아닌 함수 내부에서 새로운 코루틴을 실행하는 경우가 있다.
    
    ```kotlin
    class StringStateHolder {
      private val coroutineScope = CoroutineScope(Dispatchers.IO)
    
      var stringState = ""
        private set
    
      fun updateStringWithDelay(string: String) {
        coroutineScope.launch {
          delay(1000L)
          stringState = string
        }
      }
    }
    ```
    
    - StringStateHolder 객체는 내부에서 CoroutineScope 생성 함수를 통해 Dispatchers.IO를 사용하는 CoroutineScope 객체를 만들고, updateStringWithDelay 함수가 호출되면 이 CoroutineScope 객체를 사용해 새로운 코루틴을 실행시켜 1초간 대기 후 내부에 저장된 stringState의 상태를 변경한다.
    
    ```kotlin
    class StringStateHolderTestFail {
      @Test
      fun `updateStringWithDelay(ABC)가 호출되면 문자열이 ABC로 변경된다`() = runTest {
        // Given
        val stringStateHolder = StringStateHolder()
    
        // When
        stringStateHolder.updateStringWithDelay("ABC")
    
        // Then
        advanceUntilIdle()
        Assertions.assertEquals("ABC", stringStateHolder.stringState)
      }
    }
    ```
    
    - 위와 같이 테스트를 작성하면 실패하는 것을 확인할 수 있다.
    - 이 테스트가 실패하는 이유는 StringStateHolder 객체 내부에 있는 CoroutineScope 객체에 있다. 이 **CoroutineScope 객체는 별도의 루트 Job 객체를 갖기 때문에 runTest로 생성되는 코루틴과 구조화되지 않으며, 코루틴을 실행할 때 Dispatchers.IO를 사용하기 때문에 실제 시간 위에서 실행**된다.
    - 즉, 테스트용 스케줄러의 영향을 받지 않는다. 따라서 advanceUntilIdle 함수가 호출되더라도 실제 시간에서 그대로 실행된다. 즉, assert가 실행될 때 아직 값이 업데이트되기 전이어서 여전히 빈 문자열이다.
    - 이를 해결하기 위해서는 stringStateHolder 객체의 CoroutineScope 객체가 TestCoroutineScheduler 객체를 사용할 수 있게 해야 한다. 이를 위한 가장 쉬운 방법은 StringStateHolder 클래스의 CoroutineScope 생성 함수에서 사용하는 CoroutineDispatcher 객체를 StringStateHolder에 주입받도록 변경하는 것이다.
    
    ```kotlin
    class StringStateHolder(
      private val dispatcher: CoroutineDispatcher = Dispatchers.IO
    ) {
      private val coroutineScope = CoroutineScope(dispatcher)
    
      var stringState = ""
        private set
    
      fun updateStringWithDelay(string: String) {
        coroutineScope.launch {
          delay(1000L)
          stringState = string
        }
      }
    }
    ```
    
    ```kotlin
    class StringStateHolderTestSuccess {
      @Test
      fun `updateStringWithDelay(ABC)가 호출되면 문자열이 ABC로 변경된다`() {
        // Given
        val testDispatcher = StandardTestDispatcher()
        val stringStateHolder = StringStateHolder(
          dispatcher = testDispatcher
        )
    
        // When
        stringStateHolder.updateStringWithDelay("ABC")
    
        // Then
        testDispatcher.scheduler.advanceUntilIdle()
        Assertions.assertEquals("ABC", stringStateHolder.stringState)
      }
    }
    ```
    
    - 이 테스트에서는 일시 중단 함수를 호출하는 부분이 없기 때문에 runTest 함수로 감싸지 않는다. 대신 StandardTestDispatcher 함수를 통해 CoroutineDispatcher 객체를 만들어 StringStateHolder 객체를 초기화할 때 주입하고, StringStateHolder 내부에서 만들어진 코루틴이 모두 실행 완료됨의 보장을 위해 testDispatcher.scheduler.advanceUntilIdle()를 호출한다.

### 12.5.2. backgroundScope를 사용해 테스트 만들기

- runTest 함수를 사용해 테스를 진행할 경우 runTest 함수를 호출해 생성되는 코루틴은 메인 스레드를 사용하는데 내부의 모든 코루틴이 실행될 때까지 종료되지 않는다.
    
    ```kotlin
    @Test
    fun `메인 스레드만 사용하는 runTest`() =
        runTest {
            println(Thread.currentThread())
        }
    ```
    
    > Thread[#3,main @kotlinx.coroutines.test runner#2,5,main]
    > 
- 따라서 runTest 코루틴 내부에서 launch 함수가 호출돼 코루틴이 생성되고, 이 코루틴 내부에서 while문 같은 무한히 실행되는 작업이 실행된다면 테스트가 계속해서 실행된다.
    
    ```kotlin
    @OptIn(ExperimentalCoroutinesApi::class)
    @Test
    fun `끝나지 않아 실패하는 테스트`() =
        runTest {
            var result = 0
    
            launch {
                while (true) {
                    delay(1000L)
                    result += 1
                }
            }
    
            advanceTimeBy(1500L)
            Assertions.assertEquals(1, result)
            advanceTimeBy(1000L)
            Assertions.assertEquals(2, result)
        }
    ```
    
    > kotlinx.coroutines.test.UncompletedCoroutinesError: After waiting for 1m, there were active child jobs: ["coroutine#3":StandaloneCoroutine{Active}@3bb2a308]. Use `TestScope.backgroundScope` to launch the coroutines that need to be cancelled when the test body finishes
    > 
    - runTest 코루틴이 마지막 코드인 assertEquals를 실행하고 나서 ‘실행 완료 중’ 상태로 변경됐지만, while에 의해 launch 코루틴이 계속 실행되어 테스트가 종료되지 않기 때문이다. runTest 코루틴은 테스트가 무한히 실행되는 것을방지하려고 코루틴이 ‘실행 완료 중’ 상태로 변한 후 일정 시간(1분으로 바뀐듯?) 뒤에도 테스트가 종료되지 않으면 UncompletedCoroutinesError 예외를 던져 강제로 테스트를 실패하게 ㅂ만든다.
    - 이렇게 무한히 실행되는 작업을 테스트하기 위해서는 runTest 람다식의 수신 객체인 TestScope가 제공하는 backgroundScope를 사용해야 한다. backgroundScope는 runTest 코루틴의 모든 코드가 실행되면 자동으로 취소되며, 이를 통해 테스트가 무한히 실행되는 것을 방지할 수 있다.
    
    ```kotlin
    @Test
    fun `backgroundScope를 사용하는 테스트`() =
        runTest {
            var result = 0
    
            backgroundScope.launch {
                while (true) {
                    delay(1000L)
                    result += 1
                }
            }
    
            advanceTimeBy(1500L)
            Assertions.assertEquals(1, result)
            advanceTimeBy(1000L)
            Assertions.assertEquals(2, result)
        }
    ```
