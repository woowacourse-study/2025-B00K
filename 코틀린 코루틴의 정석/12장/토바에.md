# 코루틴 단위 테스트

## 코루틴 단위 테스트 시작하기

### 첫 코루틴 테스트 작성하기

테스트 대상 객체

```jsx
class RepeatAddUseCase {
  suspend fun add(repeatTime: Int): Int = withContext(Dispatchers.Default) {
    var result = 0
    repeat(repeatTime) {
      result += 1
    }
    return@withContext result
  }
}
```

add 일시 중단 함수는 withContext를 사용해 코루틴이 사용하는 스레드를 CPU 바운드 작업을 위한 백그라운드 스레드로 전환한다.

매개변수로 입력된 repeatTime 만큼 result에 1을 반복해 더하고 반환한다.

repeatTime과 반환된 result의 값이 같아야 한다.

테스트

```jsx
class RepeatAddUseCaseTest {
  @Test
  fun `100번 더하면 100이 반환된다`() {
    // Given
    val repeatAddUseCase = RepeatAddUseCase()

    // When
    val result = repeatAddUseCase.add(100)

    // Then
    assertEquals(100, result)
  }
}
```

<aside>
💡

Suspend function 'add' should be called only from a coroutine or another suspend function

</aside>

→ 컴파일 타임에 오류를 발생시킴

일시 중단 함수는 코루틴 내부에서 실행 돼야 하므로 테스트 함수를 runBlocking 함수로 감싸야 한다.

```jsx
class RepeatAddUseCaseTest {
  @Test
  fun `100번 더하면 100이 반환된다`() = runBlocking {
    // Given
    val repeatAddUseCase = RepeatAddUseCase()

    // When
    val result = repeatAddUseCase.add(100)

    // Then
    assertEquals(100, result)
  }
}
```

→ 정상적으로 실행된다. 하지만 runBlocking을 사용하면 실행에 시간이 오래 걸리는 함수를 테스트하면 문제가 생긴다.

### runBlocking을 사용한 테스트의 한계

```jsx
class RepeatAddWithDelayUseCase {
    suspend fun add(repeatTime: Int): Int {
        var result = 0
        repeat(repeatTime) {
            delay(100L)
            result += 1
        }
        return result
    }
}
```

```jsx
@Test
  fun `runBlocking_100번 더하면 100이 반환된다`() = runBlocking {
    // Given
    val repeatAddUseCase = RepeatAddWithDelayUseCase()

    // When
    var result = 0
    result = repeatAddUseCase.add(100)

    // Then
    assertEquals(100, result)
  }
```
테스트를 실행하는 데, 10초가 넘게 걸린다.

## 코루틴 테스트 라이브러리

테스트할 때 runblocking 함수를 사용하면 오랜 시간이 걸릴 수 있다.

이런 문제를 해결하기 위해 코루틴 테스트 라이브러리는 가상 시간을 사용하는 코루틴 스케줄러를 제공한다.

### 코루틴 테스트 라이브러리 의존성 설정하기

코루틴 테스트 라이브러리(`kotlinx-coroutines-test`)에 대한 의존성을 설정해야 한다.

`build.gradle.kts` 파일에 추가해 코루틴 테스트 라이브러리에 대한 의존성을 추가로 설정한다.

```jsx
dependencies {
	testImplementation("org.jetbrains.kotlinx:kotlinx-coroutines-test:1.7.2")
}
```

### TestCoroutineScheduler 사용해 가상 시간에서 테스트 진행하기

코루틴 테스트를 할 때, 코루틴에 오랜 시간이 걸리는 작업이 포함돼 있으면 가상 시간을 사용해 코루틴의 동작이 자신이 원하는 시간까지 단번에 진행될 수 있도록 만들 수 있다.

→ 빠르게 테스트를 완료할 수 있다

→ 시간을 자유자재로 다룰 수 있다

#### advanceTimeBy 사용해 가상 시간 흐르게 만들기

```jsx
  @Test
  fun `가상 시간 조절 테스트`() {
    // 테스트 환경 설정
    val testCoroutineScheduler = TestCoroutineScheduler()

    testCoroutineScheduler.advanceTimeBy(5000L) // 가상 시간에서 5초를 흐르게 만듦 : 현재 시간 5초
    assertEquals(5000L, testCoroutineScheduler.currentTime) // 현재 시간이 5초
    testCoroutineScheduler.advanceTimeBy(6000L) // 가상 시간에서 6초를 흐르게 만듦 : 현재 시간 11초
    assertEquals(11000L, testCoroutineScheduler.currentTime) // 현재 시간이 11초
    testCoroutineScheduler.advanceTimeBy(10000L) // 가상 시간에서 10초를 흐르게 만듦 : 현재 시간 21초
    assertEquals(21000L, testCoroutineScheduler.currentTime) // 현재 시간이 21초
  }
```

advanceTimeBy 함수를 호출하면 함수의 인자로 입력된 값만큼 가상 시간이 밀리초 단위로 흐르게 된다.

`testCoroutineScheduler.currentTime` 가상 시간이 얼마나 흘렀는지 확인하고 싶을 때 사용

#### TestCoroutineScheduler와 StandardTestDispatcher 사용해 가상 시간 위에서 테스트 진행하기

```jsx
@Test
  fun `가상 시간 위에서 테스트 진행`() {
    // 테스트 환경 설정
    val testCoroutineScheduler: TestCoroutineScheduler = TestCoroutineScheduler()
    val testDispatcher: TestDispatcher = StandardTestDispatcher(scheduler = testCoroutineScheduler)
    val testCoroutineScope = CoroutineScope(context = testDispatcher)

    // Given
    var result = 0

    // When
    testCoroutineScope.launch {
      delay(10000L) // 10초간 대기
      result = 1
      delay(10000L) // 10초간 대기
      result = 2
      println(Thread.currentThread().name)
    }

    // Then
    assertEquals(0, result)
    testCoroutineScheduler.advanceTimeBy(5000L) // 가상 시간에서 5초를 흐르게 만듦 : 현재 시간 5초
    assertEquals(0, result)
    testCoroutineScheduler.advanceTimeBy(6000L) // 가상 시간에서 6초를 흐르게 만듦 : 현재 시간 11초
    assertEquals(1, result)
    testCoroutineScheduler.advanceTimeBy(10000L) // 가상 시간에서 10초를 흐르게 만듦 : 현재 시간 21초
    assertEquals(2, result)
  }
```

TestCoroutineScheduler()를 만들고 StandardTestDispatcher에 만든 testCoroutineScheduler를 인자로 넘겨 테스트 디스패처 객체를 만든다.

생성된 testDispatcher는 CoroutineScope 인자로 넘겨져 testDispatcher 객체를 사용하는 CoroutineScope 객체를 만든다.

테스트 시 직접 시간을 컨트롤하는 경우는 거의 없다. 하지만 코루틴 테스트 라이브러리의 기능을 이해하는 데 도움이 된다.

#### advanceUntilIdle 사용해 모든 코루틴 실행시키기

```jsx
@Test
  fun `advanceUntilIdle의 동작 살펴보기`() {
    // 테스트 환경 설정
    val testCoroutineScheduler: TestCoroutineScheduler = TestCoroutineScheduler()
    val testDispatcher: TestDispatcher = StandardTestDispatcher(scheduler = testCoroutineScheduler)
    val testCoroutineScope = CoroutineScope(context = testDispatcher)

    // Given
    var result = 0

    // When
    testCoroutineScope.launch {
      delay(10_000L) // 10초간 대기
      result = 1
      delay(10_000L) // 10초간 대기
      result = 2
    }
    testCoroutineScheduler.advanceUntilIdle() // testCoroutineScope 내부의 코루틴이 모두 실행되게 만듦

    // Then
    assertEquals(2, result)
  }
```

`advanceUntilIdle` 는 연결된 모든 작업이 모두 완료될 때까지 가상 시간을 흐르게 만든다

#### TestCoroutineScheduler*를 포함하는 StandardTestDispatcher*

TestCoroutineScheduler 객체를 생성해 넘겼었지만, *StandardTestDispatcher 함수에는* TestCoroutineScheduler 객체를 생성하는 부분이 포함돼 있어 직접 생성할 필요가 없다.

```jsx
@Suppress("FunctionName")
public fun StandardTestDispatcher(
    scheduler: TestCoroutineScheduler? = null,
    name: String? = null
): TestDispatcher = StandardTestDispatcherImpl(
    scheduler ?: TestMainDispatcher.currentTestScheduler ?: ***TestCoroutineScheduler()***, name)
```

→ 인자로 받은 scheduler가 없으면 TestMainDispatcher.currentTestScheduler를 확인 후 그래도 없으면 새 객체를 내부에서 생성한다.

```jsx
@Test
  fun `StandardTestDispatcher 사용하기`() {
    // 테스트 환경 설정
    val testDispatcher: TestDispatcher = StandardTestDispatcher()
    val testCoroutineScope = CoroutineScope(context = testDispatcher)

    // Given
    var result = 0

    // When
    testCoroutineScope.launch {
      delay(10_000L) // 10초간 대기
      result = 1
      delay(10_000L) // 10초간 대기
      result = 2
    }

    testDispatcher.scheduler.advanceUntilIdle() // testCoroutineScope 내부의 코루틴이 모두 실행되게 만듦
    assertEquals(2, result)
  }
```

#### TestScope 사용해 가상 시간에서 테스트 진행하기

TestScope 함수를 호출하면 내부에 TestDispather 객체를 가진 TestScope 객체가 반환된다.

코루틴 라이브러리는 TestScope에 대한 확장 함수를 통해 TestCoroutineScheduler 객체의 함수들과 프로퍼티를  TestScope 객체가 직접 호출할 수 있도록 만든다.

```jsx
@Test
  fun `TestScope 사용하기`() {
    // 테스트 환경 설정
    val testCoroutineScope: TestScope = TestScope()

    // Given
    var result = 0

    // When
    testCoroutineScope.launch {
      delay(10000L) // 10초간 대기
      result = 1
      delay(10000L) // 10초간 대기
      result = 2
    }

    testCoroutineScope.advanceUntilIdle() // testCoroutineScope 내부의 코루틴이 모두 실행되게 만듦
    assertEquals(2, result)
  }
```

TestScope 함수는 기본적으로 StandardTestDispatcher 함수로 생성되는 TestDispatcher 객체를 포함한다.

→ 따라서 TestScope, StandardTestDispatcher, TestCoroutineScheduler 객체를 포함한다.

TestScope 객체를 직접 생성하고, TestScope 객체에 대해 advanceUntilIdel을 호출해 내부의 코루틴이 모두 실행될 때까지 가상 시간을 직접 흐르게 만들고 있다.

### runTest 사용해 테스트 만들기

#### runTest 사용해 TestScope 대체하기

runTest 함수는 모든 것을 자동으로 실행해 준다.

TestScope 객체를 사용해 코루틴을 실행시키고, 그 코루틴 내부에서 일시 중단 함수가 실행되더라도 작업이 곧바로 실행 완료될 수 있도록 가상 시간을 흐르게 만드는 기능을 가진 코루틴 빌더이다.

runBlocking 함수로 만들어지는 코루틴과 유사하게 동작하지만 지연되는 부분을 건너뛰는 코루틴이 만들어진다.

```jsx
@Test
  fun `runTest 사용하기`() {
    // Given
    var result = 0

    // When
    runTest { // this: TestScope
      delay(10000L) // 10초간 대기
      result = 1
      delay(10000L) // 10초간 대기
      result = 2
    }

    // Then
    assertEquals(2, result)
  }
```

runTest를 사용하면 가상 시간 위에서 테스트가 진행돼 코루틴에 지연 지점이 있더라도 해당 시간 동안 가상 시간을 자동으로 흐르게 만들어 빠르게 실행 완료된다.

#### runTest로 테스트 전체 감싸기

```jsx
@Test
  fun `runTest로 테스트 감싸기`() = runTest {  // this: TestScope
    // Given
    var result = 0

    // When
    delay(10000L) // 10초간 대기
    result = 1
    delay(10000L) // 10초간 대기
    result = 2

    // Then
    assertEquals(2, result)
  }
```

runTest 함수로 모든 테스트를 감싸는 이유는 테스트 환경을 설정하는 부분에서도 일시 중단 함수가 호출될 수 있고, 결과를 비교하는 부분에서도 일시 중단 함수가 호출될 수 있기 때문이다.

→ 각 부분에서 일시 중단 함수가 호출되더라도 일시 중단되는 시간을 가상 시간을 통해 빠르게 흐르게 만들 수 있음

#### runTest 함수의 람다식에서 TestScope 사용하기

runTest 함수는 람다식에서 TestScope 객체를 수신 객체로 갖기 때문에 this를 통해 TestScope 객체에 접근할 수 있다.

runTest 함수의 람다식에서는 TestScope 객체가 사용할 수 있는 advanceTimeBy, advanceUntilIdle 같은 확장 함수들과 currentTime 확장 프로퍼티를 모두 사용할 수 있다.

```jsx
@Test
  fun `runTest에서 가상 시간 확인`() = runTest {  // this: TestScope
    delay(10000L) // 10초간 대기
    println("가상 시간: ${this.currentTime}ms") // 가상 시간: 10000ms
    delay(10000L) // 10초간 대기
    println("가상 시간: ${this.currentTime}ms") // 가상 시간: 20000ms
  }
  /*
  // 결과:
  가상 시간: 10000ms
  가상 시간: 20000ms
  */
```

runTest 함수에서 advanceTimeBy 함수나 advanceUntilIdle 함수는 언제 사용할 수 있을까?

runTest의 TestScope 내부에서 새로운 코루틴이 실행될 때 해당 코루틴이 모두 실행 완료될 때까지 가상 시간을 흐르게 하는 데 사용할 수 있다.

```jsx
@Test
  fun `runTest 내부에서 advanceUntilIdle 사용하기`() = runTest {  // this: TestScope
    var result = 0
    launch {
      delay(1000L)
      result = 1
    }

    println("가상 시간: ${this.currentTime}ms, result = ${result}") // 가상 시간: 0ms, result = 0
    advanceUntilIdle()
    println("가상 시간: ${this.currentTime}ms, result = ${result}") // 가상 시간: 1000ms, result = 1
  }
```

launch 함수의 람다식 내부에서 launch 코루틴이 새롭게 생성된다.

runTest 함수는 runTest 함수로 생성된 내부에서 실행된 일시 중단 함수에 대해서만 가상 시간이 흐르게 만든다.

TestScope 상에서 새로 실행된 launch 코루틴에 대해서는 자동으로 시간을 흐르게 하지 않는다.

→ advanceUntilIdle이 호출돼야 runTest 블록 내부에서 새로 생성된 코루틴들이 실행 완료될 때까지 시간이 흐른다.

<aside>
💡

멀티 스레드 환경에서의 코루틴 테스트를 위해서는 여러 코루틴이 병렬로 실행되는 상황이 테스트 되어야 한다.

</aside>

→ 가상 시간을 흐르게 만들어 즉시 실행 완료 시키면 코루틴이 술차적으로 실행되므로 병렬 환경에서의 코루틴 테스트가 제대로 이뤄질 수 없다.

runTest 내부에서 모든 코루틴이 생성되고 나서 advanceUntilIdle을 호출해 생성된 모든 코루틴이 함께 실행될 수 있도록 해야 테스트가 제대로 이뤄질 수 있다.

```jsx
@Test
  fun `runTest 내부에서 join 사용하기`() = runTest {  // this: TestScope
    var result = 0
    launch {
      delay(1000L)
      result = 1
    }.join()

    println("가상 시간: ${this.currentTime}ms, result = ${result}") // 가상 시간: 1000ms, result = 1
  }
```

만약 runTest 코루틴의 자식 코루틴을 생성하고 해당 코루틴에 대해 join을 호출하면 advanceUntilIdle을 호출하지 않더라도 runTest 코루틴의 가상 시간이 흐른다.

→ join 함수의 호출이 runTest 코루틴을 일시 중단시키기 때문이다.

## 코루틴 단위 테스트 만들어보기

#### 코루틴 단위 테스트를 위한 코드 준비하기

```jsx
sealed class Follower(
  open val id: String,
  open val name: String
) {
  data class OfficialAccount(
    override val id: String,
    override val name: String
  ) : Follower(id, name)

  data class PersonAccount(
    override val id: String,
    override val name: String
  ) : Follower(id, name)
}
```

Follower는 서브타입으로 OfficialAccount와 PersonAccount를 가진다.

```jsx
class FollowerSearcher(
  private val officialAccountRepository: OfficialAccountRepository,
  private val personAccountRepository: PersonAccountRepository
) {
  suspend fun searchByName(name: String): List<Follower> = coroutineScope {
    val officialAccountsDeferred = async {
      officialAccountRepository.searchByName(name)
    }
    val personAccountsDeferred = async {
      personAccountRepository.searchByName(name)
    }

    return@coroutineScope listOf(
      *officialAccountsDeferred.await(),
      *personAccountsDeferred.await()
    )
  }
}
```

테스트를 작성하기 위해서는 OfficialAccountRepository와 PersonAccountRepository에 대한 테스트 더블이 필요하다.

```jsx
class StubOfficialAccountRepository(
  private val users: List<Follower.OfficialAccount>
) : OfficialAccountRepository {
  override suspend fun searchByName(name: String): Array<Follower.OfficialAccount> {
    delay(1000L)
    return users.filter { user ->
      user.name.contains(name)
    }.toTypedArray()
  }
}
```

```jsx
class StubPersonAccountRepository(
  private val users: List<Follower.PersonAccount>
) : PersonAccountRepository {
  override suspend fun searchByName(name: String): Array<Follower.PersonAccount> {
    delay(1000L)
    return users.filter { user ->
      user.name.contains(name)
    }.toTypedArray()
  }
}
```

```jsx
class FollowerSearcherTest {

  private lateinit var followerSearcher: FollowerSearcher

  @BeforeEach
  fun setUp() {
    followerSearcher = FollowerSearcher(
      officialAccountRepository = stubOfficialAccountRepository,
      personAccountRepository = stubPersonAccountRepository
    )
  }

  companion object {
    private val companyA = Follower.OfficialAccount(id = "0x0000", name = "CompanyA")
    private val companyB = Follower.OfficialAccount(id = "0x0001", name = "CompanyB")
    private val companyC = Follower.OfficialAccount(id = "0x0002", name = "CompanyC")

    private val stubOfficialAccountRepository = StubOfficialAccountRepository(
      users = listOf(companyA, companyB, companyC)
    )

    private val personA = Follower.PersonAccount(id = "0x1000", name = "PersonA")
    private val personB = Follower.PersonAccount(id = "0x1001", name = "PersonB")
    private val personC = Follower.PersonAccount(id = "0x1002", name = "PersonC")

    private val stubPersonAccountRepository = StubPersonAccountRepository(
      users = listOf(personA, personB, personC)
    )
  }
}
```

#### 테스트 작성하기

```jsx
@Test
  fun `공식 계정과 개인 계정이 합쳐져 반환되는지 테스트`() = runTest {
    // Given
    val searchName = "A"
    val expectedResults = listOf(companyA, personA)

    // When
    val results = followerSearcher.searchByName(searchName)

    // Then
    Assertions.assertEquals(
      expectedResults,
      results
    )
  }
```

일시 중단 함수인 searchByName을 테스트하기 때문에 모든 테스트를 runTest로 감싼다.

→ 지연 시간을 없앨 수 있다.

```jsx
@Test
  fun `빈 배열이 반환되는지 테스트`() = runTest {
    // Given
    val searchName = "Empty"
    val expectedResults = emptyList<Follower>()

    // When
    val results = followerSearcher.searchByName(searchName)

    // Then
    Assertions.assertEquals(
      expectedResults,
      results
    )
  }
```

## 코루틴 테스트 심화

#### 함수 내부에서 새로운 코루틴을 실행하는 객체에 대한 테스트

일시 중단 함수 내부에서 새로운 코루틴을 생성하는 동작은 테스트하기 쉽다.

하지만 일시 중단 함수가 아닌 함수 내부에서 새로운 코루틴을 실행하는 경우가 있다.

```jsx
class StringStateHolder {
  private val coroutineScope = CoroutineScope(Dispatchers.IO)

  var stringState = ""
    private set

  fun updateStringWithDelay(string: String) {
    coroutineScope.launch {
      delay(1000L)
      stringState = string
    }
  }
}
```

```jsx
class StringStateHolderTestFail {
  @Test
  fun `updateStringWithDelay(ABC)가 호출되면 문자열이 ABC로 변경된다`() = runTest {
    // Given
    val stringStateHolder = StringStateHolder()

    // When
    stringStateHolder.updateStringWithDelay("ABC")

    // Then
    advanceUntilIdle()
    Assertions.assertEquals("ABC", stringStateHolder.stringState)
  }
}
```

테스트는 빈 문자열로 실패한다.

StringStateHolder 객체 내부에 있는 CoroutineScope 객체 때문이다.

CoroutineScope 객체는 루트 Job 객체를 갖기 때문에 runTest로 생성되는 코루틴과 구조화되지 않는다.

코루틴을 실행할 때 Dispatchers.IO를 사용하기 때문에 실제 시간 위에서 실행된다.

어떻게 해결할까?

CoroutineScope 객체가 TestCoroutineScheduler 객체를 사용할 수 있게 해야 한다.

가장 쉬운 방법은 CoroutineScope 생성 함수에서 사용하는 CoroutineDispatcher 객체를 StringStateHolder에 주입받도록 구현을 변경하는 것이다.

```jsx
class StringStateHolder(
  private val dispatcher: CoroutineDispatcher = Dispatchers.IO
) {
  private val coroutineScope = CoroutineScope(dispatcher)

  var stringState = ""
    private set

  fun updateStringWithDelay(string: String) {
    coroutineScope.launch {
      delay(1000L)
      stringState = string
    }
  }
}
```

```jsx
fun `updateStringWithDelay(ABC)가 호출되면 문자열이 ABC로 변경된다`() {
    // Given
    val testDispatcher = StandardTestDispatcher()
    val stringStateHolder = StringStateHolder(
      dispatcher = testDispatcher
    )

    // When
    stringStateHolder.updateStringWithDelay("ABC")

    // Then
    testDispatcher.scheduler.advanceUntilIdle()
    Assertions.assertEquals("ABC", stringStateHolder.stringState)
  }
```

이 테스트에서는 일시 중단 함수를 호출하는 부분이 없기 때문에 runTest 함수를 사용하지 않는다.

대신 StandardTestDispatcher를 통해 CoroutineDispatcher 객체를 만들어 StringStateHolder를 초기화할 때 주입하고, 객체 내부에서 만들어진 코루틴이 모두 실행 완료됨을 보장하기 위해 `testDispatcher.scheduler.advanceUntilIdle()` 를 호출한다.

#### backgroundScope를 사용해 테스트 만들기

runTest 함수를 사용해 테스트를 진행할 경우 runTest 함수를 호출해 생성하는 코루틴은 메인 스레드를 사용하는데 내부의 모든 코루틴이 실행될 때까지 종료되지 않는다.

```jsx
  @Test
  fun `메인 스레드만 사용하는 runTest`() = runTest {
    println(Thread.currentThread())
  }
  /*
  // 결과:
  Thread[Test worker @kotlinx.coroutines.test runner#5,5,main]
  */
```

runTest 코루틴 내부에서 launch 함수가 호출돼 코루틴이 생성되고, 이 코루틴 내부에서 while문 같은 무한히 실행되는 작업이 실행된다면 테스트가 계속해서 실행된다.

```jsx
@OptIn(ExperimentalCoroutinesApi::class)
  @Test
  fun `끝나지 않아 실패하는 테스트`() = runTest {
    var result = 0

    launch {
      while (true) {
        delay(1000L)
        result += 1
      }
    }

    advanceTimeBy(1500L)
    Assertions.assertEquals(1, result)
    advanceTimeBy(1000L)
    Assertions.assertEquals(2, result)
  }

  /*
  // 결과:
  After waiting for 10s, the test coroutine is not completing, there were active child jobs: ["coroutine#3":StandaloneCoroutine{Active}@381f03c1]
  kotlinx.coroutines.test.UncompletedCoroutinesError: After waiting for 10s, the test coroutine is not completing, there were active child jobs: ["coroutine#3":StandaloneCoroutine{Active}@381f03c1]
  at app//kotlinx.coroutines.test.TestBuildersKt__TestBuildersKt$runTest$2$1$2$1.invoke(TestBuilders.kt:349)
  at app//kotlinx.coroutines.test.TestBuildersKt__TestBuildersKt$runTest$2$1$2$1.invoke(TestBuilders.kt:333)
  ...
  */
```

runTest 내부에서 launch 함수를 호출해 새로운 코루틴을 생성하고 1초마다 result의 값을 1씩 증가시킨다.

결과의 의미는 runTest 코루틴이 마지막 코드인 Assertions.assertEquals(2, result)를 실행하고 나서 ‘실행 완료 중’ 상태로 변경됐지만 while문에 의해 launch 코루틴이 계속해서 실행돼 테스트가 종료되지 않았기 때문이다.

runTest 코루틴이 테스트가 무한히 실행되는 것을 방지하려고 코루틴이 ‘실행 완료 중’ 상태로 변한 후 일정 시간 뒤에도 테스트가 종료되지 않으면 UnCompletedCoroutinesError 예외를 던져 강제로 테스트를 실패하게 만든다.

```jsx
@Test
  fun `backgroundScope를 사용하는 테스트`() = runTest {
    var result = 0

    backgroundScope.launch {
      while (true) {
        delay(1000L)
        result += 1
      }
    }

    advanceTimeBy(1500L)
    Assertions.assertEquals(1, result)
    advanceTimeBy(1000L)
    Assertions.assertEquals(2, result)
  }
```

무한히 실행되는 작업을 테스트하기 위해서는 runTest 람다식의 수신 객체인 TestScope가 제공하는 backgroundScope를 사용해야 한다.

backgroundScope는 runTest 코루틴의 모든 코드가 실행되면 자동으로 취소되며, 이를 통해 테스트가 무한히 실행되는 것을 방지할 수 있다.
