0) 왜 코루틴 테스트가 특별한가
코루틴은 비동기 + 일시중단(suspend) + 시간 지연(delay) 을 다룹니다.

단위 테스트에선 가상 시간을 쓰면, 실제로 기다리지 않고도 즉시 검증이 가능합니다.

핵심 도구는 runTest, TestCoroutineScheduler, StandardTestDispatcher, TestScope, advanceUntilIdle, advanceTimeBy 입니다.

1) Gradle 의존성 설정
kotlin
복사
편집
// build.gradle.kts (모듈)
dependencies {
    // JUnit 5
    testImplementation("org.junit.jupiter:junit-jupiter-api:5.10.2")
    testRuntimeOnly("org.junit.jupiter:junit-jupiter-engine:5.10.2")

    // 코루틴 테스트
    testImplementation("org.jetbrains.kotlinx:kotlinx-coroutines-test:1.8.1")
}
Android Local Unit Test에서 Dispatchers.Main을 쓰면 필요에 따라 androidx.test:core와 MainDispatcherRule 패턴이 유용합니다(아래 §7.2).

2) 단위 테스트 구조와 수명주기
2.1 기본 테스트 골격
kotlin
복사
편집
import org.junit.jupiter.api.Assertions.*
import org.junit.jupiter.api.BeforeEach
import org.junit.jupiter.api.Test

class Calculator {
    fun add(a: Int, b: Int) = a + b
}

class CalculatorTest {
    private lateinit var sut: Calculator  // System Under Test

    @BeforeEach
    fun setup() {
        sut = Calculator()
    }

    @Test
    fun `2 더하기 2는 4`() {
        assertEquals(4, sut.add(2, 2))
    }
}
2.2 실행 흐름 다이어그램
mermaid
복사
편집
flowchart LR
  A[테스트 시작] --> B@BeforeEach 실행
  B --> C@Test 실행
  C -->|성공| D[Assertions OK]
  C -->|실패| E[Fail: Assertion Error]
  D --> F[테스트 종료]
  E --> F
3) 테스트 더블: Stub vs Fake
3.1 예제 시나리오
UserProfileFetcher가 두 저장소에서 이름과 전화번호를 가져와 UserProfile을 만든다고 가정.

kotlin
복사
편집
data class UserProfile(val name: String, val phone: String)

interface UserNameRepository {
    fun getUserName(userId: String): String
}

interface UserPhoneRepository {
    fun getPhone(userId: String): String
}

class UserProfileFetcher(
    private val nameRepo: UserNameRepository,
    private val phoneRepo: UserPhoneRepository
) {
    fun fetch(userId: String): UserProfile {
        return UserProfile(
            name = nameRepo.getUserName(userId),
            phone = phoneRepo.getPhone(userId)
        )
    }
}
3.2 Stub과 Fake 구현
kotlin
복사
편집
// Stub: 미리 정해진 값만 반환
class StubUserNameRepository(private val name: String) : UserNameRepository {
    override fun getUserName(userId: String) = name
}

// Fake: 조금 더 실제에 가까운 동작 흉내
class FakeUserPhoneRepository : UserPhoneRepository {
    private val store = mutableMapOf<String, String>()
    fun seed(userId: String, phone: String) { store[userId] = phone }
    override fun getPhone(userId: String) = store[userId] ?: "N/A"
}
3.3 테스트
kotlin
복사
편집
import org.junit.jupiter.api.Test
import org.junit.jupiter.api.Assertions.*

class UserProfileFetcherTest {
    @Test
    fun `이름과 번호를 합쳐 UserProfile을 만든다`() {
        val stubNameRepo = StubUserNameRepository("홍길동")
        val fakePhoneRepo = FakeUserPhoneRepository().apply { seed("42", "010-1234-5678") }

        val sut = UserProfileFetcher(stubNameRepo, fakePhoneRepo)
        val profile = sut.fetch("42")

        assertEquals("홍길동", profile.name)
        assertEquals("010-1234-5678", profile.phone)
    }
}
4) runBlocking과 그 한계
4.1 간단한 suspend 테스트
kotlin
복사
편집
import kotlinx.coroutines.runBlocking
import org.junit.jupiter.api.Assertions.assertEquals
import org.junit.jupiter.api.Test

suspend fun greet(): String = "OK"

class SimpleSuspendTest {
    @Test
    fun `runBlocking으로 간단한 일시중단 함수 테스트`() = runBlocking {
        assertEquals("OK", greet())
    }
}
4.2 한계
실제 delay(1000)은 진짜 1초를 기다립니다.

느리고, 테스트가 불안정해집니다.

해결책: 가상 시간을 제공하는 kotlinx-coroutines-test의 runTest 사용.

5) 가상 시간: runTest, TestCoroutineScheduler, StandardTestDispatcher
5.1 핵심 아이디어
runTest { ... } 블록 내부는 기본적으로 가상 시간을 사용합니다.

블록 내부의 delay(...)는 실제 대기 없이 즉시 스킵됩니다.

단, runTest의 바깥에서 만든 코루틴이나, 별도 스코프/디스패처를 사용하면 자동 시간 스킵이 적용되지 않을 수 있습니다.

5.2 가장 간단한 runTest
kotlin
복사
편집
import kotlinx.coroutines.delay
import kotlinx.coroutines.test.runTest
import org.junit.jupiter.api.Assertions.assertEquals
import org.junit.jupiter.api.Test

class RunTestBasics {
    @Test
    fun `runTest는 delay를 즉시 스킵한다`() = runTest {
        var x = 0
        x += 1
        delay(1_000) // 실제로 기다리지 않음
        x += 1
        assertEquals(2, x)
    }
}
5.3 스케줄러 직접 제어: advanceTimeBy, advanceUntilIdle
kotlin
복사
편집
import kotlinx.coroutines.*
import kotlinx.coroutines.test.*

class VirtualTimeTest {
    @Test
    fun `스케줄러로 가상 시간 수동 진행`() = runTest {
        val dispatcher = StandardTestDispatcher(testScheduler)

        var value = 0

        launch(dispatcher) {
            delay(1_000)
            value = 42
        }

        // 아직 실행 전
        assertEquals(0, value)

        // 1000ms만큼 가상 시간 진행
        testScheduler.advanceTimeBy(1_000)

        assertEquals(42, value)

        // 남아있는 모든 작업 소진
        testScheduler.advanceUntilIdle()
    }
}
다이어그램으로 보면:

mermaid
복사
편집
sequenceDiagram
  participant T as Test(runTest)
  participant D as StandardTestDispatcher
  participant S as TestScheduler

  T->>D: launch { delay(1000); value=42 }
  Note right of D: 지연된 작업은 스케줄러 큐에 저장
  T->>S: advanceTimeBy(1000)
  S-->>D: 대기중 태스크 실행
  D-->>T: value=42 완료
6) TestScope와 추가 코루틴 제어
6.1 TestScope 직접 쓰기
runTest 내부에 기본 TestScope가 존재합니다.

별도로 만들고 싶다면 TestScope(StandardTestDispatcher())처럼 구성할 수 있습니다.

kotlin
복사
편집
import kotlinx.coroutines.launch
import kotlinx.coroutines.test.*

class TestScopeExample {
    @Test
    fun `직접 만든 TestScope로 제어`() {
        val scheduler = TestCoroutineScheduler()
        val dispatcher = StandardTestDispatcher(scheduler)
        val scope = TestScope(dispatcher)

        var counter = 0

        scope.launch {
            delay(500)
            counter++
        }

        // 아직 실행 전
        assert(counter == 0)

        scope.advanceTimeBy(500)
        assert(counter == 1)

        scope.advanceUntilIdle()
    }
}
7) 실전 레시피
7.1 UseCase 테스트: Dispatcher 주입
kotlin
복사
편집
import kotlinx.coroutines.CoroutineDispatcher
import kotlinx.coroutines.withContext

class RepeatAddUseCase(
    private val dispatcher: CoroutineDispatcher
) {
    suspend fun add(repeat: Int): Int = withContext(dispatcher) {
        var result = 0
        repeat(repeat) { result += 1 }
        result
    }
}
테스트에서는 TestDispatcher 주입:

kotlin
복사
편집
import kotlinx.coroutines.test.*
import org.junit.jupiter.api.Assertions.assertEquals
import org.junit.jupiter.api.Test

class RepeatAddUseCaseTest {
    @Test
    fun `가상 시간에서 빠르게 수행`() = runTest {
        val useCase = RepeatAddUseCase(StandardTestDispatcher(testScheduler))

        val result = useCase.add(1_000_000) // 매우 큰 반복이라도 스레드 전환 비용만
        assertEquals(1_000_000, result)
    }
}
withContext(Dispatchers.Default) 직접 하드코딩하지 말고 주입하세요. 그래야 테스트에서 쉽게 대체 가능합니다.

7.2 Android에서 Dispatchers.Main 쓰는 코드 테스트
Main 대체용 Rule(JUnit4) 패턴 예:

kotlin
복사
편집
// 테스트 util
@OptIn(ExperimentalCoroutinesApi::class)
class MainDispatcherRule(
    val testDispatcher: TestDispatcher = StandardTestDispatcher()
) : TestWatcher() {
    override fun starting(description: org.junit.runner.Description?) {
        Dispatchers.setMain(testDispatcher)
    }
    override fun finished(description: org.junit.runner.Description?) {
        Dispatchers.resetMain()
    }
}
사용:

kotlin
복사
편집
@OptIn(ExperimentalCoroutinesApi::class)
class ViewModelTest {
    @get:Rule
    val mainDispatcherRule = MainDispatcherRule()

    @Test
    fun `Main 사용 코드도 가상 시간으로 테스트`() = runTest {
        // ViewModel 내부가 Dispatchers.Main 사용해도 테스트 가능
    }
}
JUnit5에선 @RegisterExtension 또는 @BeforeEach/@AfterEach로 유사하게 구성합니다.

8) runTest의 시간 전파 규칙과 주의점
8.1 규칙 요약
runTest { ... } 내부에서 직접 시작된 코루틴은 시간 자동 스킵 대상.

하지만 runTest의 testScope를 받아 별도로 launch한 경우나, 외부 스코프/디스패처에서 동작하는 코루틴은 자동 스킵이 아닐 수 있음 → advanceUntilIdle 등 명시적 진행 필요.

kotlin
복사
편집
@Test
fun `새로운 TestScope로 만든 코루틴은 수동 진행 필요`() = runTest {
    val another = TestScope(StandardTestDispatcher(testScheduler))
    var hit = false

    another.launch {
        delay(100)
        hit = true
    }

    // 아직 false
    assert(!hit)

    // 수동으로 시간 진행
    another.advanceTimeBy(100)
    assert(hit)
}
다이어그램:

mermaid
복사
편집
flowchart TB
  A[runTest 스코프] -->|자동 시간 스킵| B[runTest 내부 코루틴]
  A -->|자동 아님| C[별도 TestScope 코루틴]
  C -->|advanceTimeBy/UntilIdle 필요| D[완료]
9) 병합 패턴 예시: FollowerSearcher
9.1 모델과 저장소
kotlin
복사
편집
sealed interface Follower {
    val name: String
}
data class OfficialAccount(override val name: String, val bizId: String) : Follower
data class PersonAccount(override val name: String, val uid: String) : Follower

interface OfficialAccountRepository {
    suspend fun findByName(name: String): List<OfficialAccount>
}
interface PersonAccountRepository {
    suspend fun findByName(name: String): List<PersonAccount>
}
9.2 검색기와 테스트 더블
kotlin
복사
편집
class FollowerSearcher(
    private val officialRepo: OfficialAccountRepository,
    private val personRepo: PersonAccountRepository
) {
    suspend fun searchByName(name: String): List<Follower> {
        val official = officialRepo.findByName(name)
        val personal = personRepo.findByName(name)
        return official + personal
    }
}

// Stubs
class StubOfficialRepo(private val data: List<OfficialAccount>) : OfficialAccountRepository {
    override suspend fun findByName(name: String) = data.filter { it.name.contains(name) }
}
class StubPersonRepo(private val data: List<PersonAccount>) : PersonAccountRepository {
    override suspend fun findByName(name: String) = data.filter { it.name.contains(name) }
}
9.3 테스트 (runTest 사용)
kotlin
복사
편집
import kotlinx.coroutines.test.runTest
import org.junit.jupiter.api.Assertions.assertEquals
import org.junit.jupiter.api.Test

class FollowerSearcherTest {
    @Test
    fun `두 저장소 결과를 병합하여 리턴`() = runTest {
        val official = listOf(OfficialAccount("Kotlin", "biz-1"))
        val personal = listOf(PersonAccount("Kotlin Dev", "u-1"))

        val sut = FollowerSearcher(
            officialRepo = StubOfficialRepo(official),
            personRepo = StubPersonRepo(personal)
        )

        val result = sut.searchByName("Kot")
        assertEquals(2, result.size)
    }
}
10) 일반 함수 내부에서 코루틴을 시작하는 객체 테스트
10.1 문제 상황
일반 함수가 내부에서 scope.launch(Dispatchers.IO) { ... } 같은 코루틴을 시작하면, 실제 시간과 실 스레드를 쓰기 쉬워 테스트가 어렵습니다.

해결책: Dispatcher/Scope를 주입해서 테스트에서 대체합니다.

kotlin
복사
편집
class StringStateHolder(
    private val scope: CoroutineScope,
    private val dispatcher: CoroutineDispatcher
) {
    var state: String = ""
        private set

    fun fetch() {
        scope.launch(dispatcher) {
            delay(1000)
            state = "DONE"
        }
    }
}
테스트:

kotlin
복사
편집
import kotlinx.coroutines.test.*
import org.junit.jupiter.api.Assertions.assertEquals
import org.junit.jupiter.api.Test

class StringStateHolderTest {
    @Test
    fun `fetch는 가상 시간 뒤에 상태를 변경한다`() = runTest {
        val holder = StringStateHolder(this, StandardTestDispatcher(testScheduler))
        holder.fetch()

        // 아직 변경 전
        assertEquals("", holder.state)

        // 1초 진행
        testScheduler.advanceTimeBy(1_000)

        assertEquals("DONE", holder.state)
    }
}
다이어그램:

mermaid
복사
편집
sequenceDiagram
  participant Test as Test(runTest)
  participant Holder as StringStateHolder
  participant D as StandardTestDispatcher
  Test->>Holder: fetch()
  Holder->>D: launch { delay(1000); state="DONE" }
  Test->>D: advanceTimeBy(1000)
  D-->>Holder: 실행 재개, state="DONE"
11) 무한 루프 코루틴 테스트
11.1 문제
runTest는 내부 코루틴이 끝날 때까지 블록을 종료하지 않습니다.

테스트 중 launch { while(true) { delay(...) } } 같은 무한 작업이 있으면 절대 끝나지 않음.

11.2 해법: backgroundScope
runTest의 수신객체가 제공하는 backgroundScope는 테스트 종료 시 자동 취소됩니다.

kotlin
복사
편집
import kotlinx.coroutines.delay
import kotlinx.coroutines.launch
import kotlinx.coroutines.test.runTest
import org.junit.jupiter.api.Test

class InfiniteLoopTest {
    @Test
    fun `backgroundScope는 runTest 종료와 함께 자동 취소`() = runTest {
        backgroundScope.launch {
            while (true) {
                delay(1000)
                // do something
            }
        }
        // 여기에 테스트 검증 로직...
        // runTest 블록이 끝나면 backgroundScope는 자동 취소되어 무한 루프가 테스트를 막지 않음
    }
}
12) 자주 쓰는 패턴 정리
12.1 Dispatcher Provider 패턴
kotlin
복사
편집
interface DispatcherProvider {
    val Main: CoroutineDispatcher
    val IO: CoroutineDispatcher
    val Default: CoroutineDispatcher
}

object DefaultDispatcherProvider : DispatcherProvider {
    override val Main = Dispatchers.Main
    override val IO = Dispatchers.IO
    override val Default = Dispatchers.Default
}

// 프로덕션 코드에서 주입
class SomeUseCase(private val dp: DispatcherProvider) {
    suspend fun work(): String = withContext(dp.IO) {
        // ...
        "OK"
    }
}

// 테스트에서는 TestDispatcher로 대체
class TestDispatcherProvider(
    private val test: TestDispatcher
) : DispatcherProvider {
    override val Main = test
    override val IO = test
    override val Default = test
}
테스트:

kotlin
복사
편집
@OptIn(ExperimentalCoroutinesApi::class)
class SomeUseCaseTest {
    @Test
    fun `모든 Dispatcher를 TestDispatcher로 대체`() = runTest {
        val dp = TestDispatcherProvider(StandardTestDispatcher(testScheduler))
        val sut = SomeUseCase(dp)

        val result = sut.work()
        assert(result == "OK")
    }
}
12.2 시간 제어 체크리스트
runTest 내부인가?

테스트 대상이 사용하는 Dispatcher가 주입 가능한가?

별도 스코프/디스패처를 만들었다면 advanceTimeBy/advanceUntilIdle 호출했는가?

무한 루프라면 backgroundScope를 이용했는가?

