# 코루틴 빌더와 Job
코루틴 빌더 함수
- runBlocking
- launch


모든 코루틴 빌더 함수
- 코루틴을 만든다.
- 코루틴을 추상화한 Job 객체를 생성한다.

launch 함수를 호출하면 코루틴이 만들어지고, Job 객체가 생성돼 반환된다.
반환된 Job 객체는 코루틴의 상태를 추적하고 제어하는 데 사용된다.

코루틴을 추상화한 Job 객체는 실행 도중 일시 중단된 후 나중에 실행될 수 있는 것에 대응해 코루틴을 제어할 수 있는 함수와 코루틴의 상태를 나타내는 상태 값들을 외부에 노출한다.

## join을 사용한 코루틴 순차 처리
코루틴 간에는 순차 처리가 필요한 경우가 발생한다.
ex) 데이터베이스 작업을 순차적으로 처리해야 하는 상황, 캐싱된 토큰 값이 업데이트된 이후에 네트워크 요청을 해야 하는 상황 등

Job 객체는 순차 처리가 필요한 상황을 위해 join 함수를 제공해 먼저 처리돼야 하는 코루틴의 실행이 완료될 때까지 호출부의 코루틴을 일시 중단하도록 만들 수 있다.

### 순차 처리가 안 될 경우의 문제
토큰 업데이트 작업과 네트워크 요청 작업 간에 순차 처리가 되지 않은 코드를 실행해 보면, 토큰 업데이트 시작 이후 토큰 업데이트가 끝나기 전에 네트워크 요청을 한다.
그러한 이유는, 토큰 업데이트 Job을 생성해 디스패처에 코루틴을 실행 요청한다. 디스패처는 스레드에 해당 코루틴을 할당해 실행시킨다.
네트워크 호출 Job을 생성하고 디스패처에 해당 코루틴을 실행 요청한다. 이미 점유하고 있는 스레드 대신 다른 스레드에 보내 실행시킨다.

-> 이 코드에서는 인증 토큰 업데이트 작업과 네트워크 요청 작업이 병렬로 동시에 실행된다.

이를 해결하기 위해 Job 객체는 순차 처리할 수 있는 join 함수를 제공한다.

### join 함수 사용해 순차 처리하기
Job 객체의 join 함수를 사용하면 코루틴 간에 순차 처리가 가능하다.
JobA 코루틴이 완료된 후에 JobB 코루틴이 실행돼야 한다면 JobB 코루틴이 실행되기 전에 JobA 코루틴에 join() 함수를 호출하면 된다.

Job 객체의 join() 함수를 호출하면 join()의 대상이 된 코루틴의 작업이 완료될 때까지 join()을 호출한 코루틴이 일시 중단된다.

join() 함수를 호출한 코루틴은 join의 대상이 된 코루틴이 완료될 때까지 일시 중단된다.
join() 함수는 일시 중단이 가능한 지점에서만 호출될 수 있다.

join() 함수는 join()을 호출한 코루틴만 일시 중단한다.


## joinAll을 사용한 코루틴 순차 처리
서로 독립적인 여러 코루틴을 병렬로 실행한 후 실행한 요청들이 모두 끝날 때까지 기다렸다가 다음 작업을 진행하는 것이 효율적이다.

### joinAll 함수
joinAll의 대상이 된 코루틴들의 실행이 모두 끝날 때까지 호출부의 코루틴을 일시 중단한다.

## CoroutineStart.LAZY 사용해 코루틴 지연 시작하기
launch 함수를 사용해 코루틴을 생성하면 사용할 수 있는 스레드가 있는 경우 곧바로 실행된다.
나중에 실행돼야 할 코루틴을 미리 생성해야 할 때, 코루틴 라이브러리는 생성된 코루틴을 지연 시작할 수 있는 기능을 제공한다.

launch 함수의 start 인자로 CoroutineStart.LAZY를 넘겨 코루틴 지연 시작 옵션을 적용한다.
실행시키고 싶다면, 해당 Job.start()를 하면 된다.

## 코루틴 취소하기
코루틴이 실행될 필요가 없어졌음에도 취소하지 않고 계속해서 실행되도록 두면 코루틴은 계속 스레드를 사용하므로, 애플리케이션의 성능 저하로 이어진다.

### cancel 사용해 Job 취소하기
cancel() 함수를 호출한 이후에 곧바로 다른 작업을 실행하면 해당 작업은 코루틴이 취소되기 전에 실행될 수 있다.
cancel() 함수를 사용하면, cancel의 대상이 된 Job 객체는 곧바로 취소되는 것이 아니라 미래의 어느 시점에 취소된다.
-> cancel() 함수 실행 즉시, 취소되는 것이 아니기 때문에 longJob 코루틴이 취소된 이후 실행되는 것을 보장할 수 없다.

순차성 보장을 위해 cancelAndJoin() 함수를 사용하면 취소에 대한 순차 처리가 가능해진다.

cancel()은 취소 신청, cancelAndJoin()은 취소 신청 후 취소 될 때까지 대기 같은 느낌.

## 코루틴의 취소 확인
cancel(), cancelAndJoin()을 사용했다고 즉시 취소되는 것은 아니다.
Job 객체 내부에 있는 취소 확인용 플래그를 바꾸기만 한다.
코루틴이 해당 플래그를 확인하는 시점에 비로소 취소된다.
-> 만약 코루틴이 취소를 확인할 수 있는 시점이 없다면 취소는 일어나지 않는다.

코루틴이 취소를 확인하는 시점은 언제일까?
-> 일반적으로 일시 중단 지점이나 코루틴이 실행을 대기하는 시점이다.
이 시점들이 없다면 코루틴이 취소되지 않는다.

<img width="328" alt="스크린샷 2025-06-10 오후 1 44 46" src="https://github.com/user-attachments/assets/65ab8ff2-bc42-4563-b08b-61cf49cddad8" />

해당 코루틴은 whileJob 코루틴이 100밀리초 후 취소될 것 같지만 종료되지 않고 "작업 중"이 무제한 출력된다.

whileJob 코루틴이 취소되지 않는 이유는 코루틴 블록 내부에 코루틴의 취소를 확인할 수 있는 시점이 없기 때문이다.
-> 코루틴은 일반적으로 실행 대기 시점이나 일시 중단 지점에 취소를 확인한 후 취소되는데 whileJob 코루틴은 while문에서 코드가 반복해 실행되고 있어 while문을 벗어날 수 없다.
-> while문 내부에도 일시 중단 지점이 없기 때문에 일시 중단이 일어날 수 없다.

코드가 취소되도록 만드는 방법 3가지
1. delay를 사용한 취소 확인
2. yield를 사용한 취소 확인
3. CoroutineScope.isActive를 사용한 취소 확인


### delay를 사용한 취소 확인
delay 함수는 일시 중단 함수(suspend fun)로 선언돼 특정 시간만큼 호출부의 코루틴을 일시 중단하게 만든다.
코루틴은 일시 중단되는 시점에 코루틴의 취소를 확인하기 때문에 다음과 같이 작업 중간에 delay(1L)을 주게 되면 while문이 반복될 때마다 1밀리초만큼 일시 중단 후 취소를 확인할 수 있다.
-> 해당 방법은 while문이 반복될 때마다 작업을 강제로 1밀리초 동안 일시 중단 시킨다는 점에서 효율적이지 않다.
-> 불필요하게 작업을 지연시켜 성능 저하가 일어날 것이다.

### yield를 사용한 취소 확인
yield는 양보라는 뜻이다. yield()가 호출되면 코루틴은 자신이 사용하던 스레드를 양보한다.
스레드를 양보한다 == 스레드 사용을 중단한다.
yield를 호출한 코루틴이 일시 중단되며 이 시점에 취소됐는지 체크가 일어난다.
-> while문을 한 번 돌 때마다 스레드 사용이 양보되면서 일시 중단되는 문제가 있다.
-> 코루틴이 경량 스레드라고 하지만, 매번 일시 중단되는 것은 작업을 비효율적으로 만든다.

### CoroutineScope.isActive를 사용한 취소 확인
CoroutineScope는 코루틴이 활성화됐는지 확인할 수 있는 Boolean 타입의 프로퍼티인 isActive를 제공한다.
코루틴에 취소가 요청되면 this.isActive 프로퍼티의 값은 false로 변경된다.
while문의 인자로 this.isActive를 넘기면 코루틴이 취소 요청될 때 while문이 취소되도록 만들 수 있다.
-> 코루틴이 잠시 멈추지도 않고 스레드 사용을 양보하지 않으면서 계속해서 작업을 할 수 있어서 효율적이다.
-> 코루틴 내부의 작업이 일시 중단 지점 없이 계속된다면 명시적으로 코루틴이 취소됐는지 확인하는 코드를 넣어줌으로써 코드를 취소할 수 있도록 만들어야 한다.
-> 그렇지 않으면 코루틴 취소가 동작하지 않는다.

## 코루틴의 상태와 Job의 상태 변수

<img width="523" alt="스크린샷 2025-06-10 오후 2 02 10" src="https://github.com/user-attachments/assets/faaaa24e-4151-44ca-95a7-72da8dd4aacd" />

생성
- 코루틴 빌더를 통해 코루틴을 생성하면 코루틴은 기본적으로 생성 상태에 놓인다.
- 자동으로 실행 중 상태로 넘어간다.
- 실행 중 상태로 자동으로 변경되지 않도록 만들고 싶다면 코루틴의 start 인자로 CoroutineStart.Lazy를 넘겨 지연 코루틴을 만들어야 한다.

실행 중
- 지연 코루틴이 아닌 코루틴을 만들면 자동으로 실행 중 상태로 바뀐다.
- 코루틴이 실제로 실행 중일 때뿐만 아니라 실행된 후에 일시 중단된 때도 실행 중 상태로 본다.

실행 완료
- 코루틴의 모든 코드가 실행 완료된 경우

취소 중
- Job.cancel() 등을 통해 코루틴에 취소가 요청됐을 경우 취소 중 상태로 넘어간다.
- 아직 취소된 상태가 아니어서 코루틴은 계속 실행된다.

취소 완료
- 코루틴의 취소 확인 시점에 취소가 확인된 경우 취소 완료 상태가 된다.
- 이 상태에서는 코루틴은 더 이상 실행되지 않는다.

코루틴은 이와 같은 상태를 가질 수 있다.
Job 객체는 코루틴이 어떤 상태에 있는지 나타내는 상태 변수들을 외부로 공개한다. -> Job 객체는 코루틴을 추상화한 객체이므로 노출하는 상태 변수들은 코루틴의 상태를 간접적으로만 나타낸다.

Job 객체에서 외부로 공개하는 코루틴의 상태 변수
1. isActive
- 코루틴이 활성화돼 있는지의 여부
- 코루틴이 활성화돼 있으면 true를 반환하고 활성화돼 있지 않으면 false를 반환한다.
- 취소가 요청되거나 실행이 완료된 코루틴은 활성화되지 않은 것으로 본다.

2. isCancelled
- 코루틴이 취소 요청됐는지의 여부
- 코루틴이 취소 요청되면 true를 반환한다.
- 요청되기만 하면 true가 반환되므로 isCancelled가 true이더라도 즉시 취소되는 것은 아니다.

3. isCompleted
- 코루틴 실행이 완료됐는지의 여부
- 코루틴의 모든 코드가 실행 완료되거나 취소 완료되면 true를 반환한다. 실행 중인 상태에서는 false를 반환한다.

<img width="537" alt="스크린샷 2025-06-10 오후 2 15 04" src="https://github.com/user-attachments/assets/cd272003-3c29-4e78-a1f5-311e339e19fb" />



